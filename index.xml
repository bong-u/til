<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bong-u/til</title><link>https://bong-u.github.io/til/</link><description>Recent content on bong-u/til</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 02 Feb 2023 00:00:00 +0900</lastBuildDate><atom:link href="https://bong-u.github.io/til/index.xml" rel="self" type="application/rss+xml"/><item><title>정보처리기사 실기 준비</title><link>https://bong-u.github.io/til/etc/ipe_practical/</link><pubDate>Wed, 02 Jul 2025 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/ipe_practical/</guid><description> 볼드체의 개념은 기출 문제에서 등장, 나머지 개념은 모의고사에서 등장 SW 공학 관련 개념 SOLID 원칙 S : 단일 책임 원칙 (SRP) O : 개방 폐쇄 원칙 (OCP) : 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다는 원칙 L : 리스코프 치환 원칙 (LSP) : 서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다는 원칙 I : 인터페이스 분리 원칙 (ISP) D : 의존 역전 원칙 (DIP) : 추상화에 의존해야 한다는 원칙 SOA(Service-Oriented Architecture) : 서비스 지향 아키텍처 Walk Through : 검토 자료를 회의 전에 배포해서 사전검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 오류를 검출하고 문서로 만드는 기법 정형 명세 기법 : 사용자의 요구를 표현할 때 수학적 원리와 표기법으로 서술하는 기법 Abstract Factory Pattern : 생성 패턴; 객체 생성에 대한 인터페이스를 제공하고, 구체적인 클래스는 서브클래스에서 정의하는 패턴 Decorator Pattern : 구조 패턴; 객체에 추가적인 책임을 동적으로 부여하는 패턴 Memento Pattern : 행동 패턴; 객체의 상태를 저장하고 복원하는 패턴 이상 현상 : 데이터를 데이터베이스에 저장할때 불필요하게 중복되어 릴레이션 조작시 예기치 못한 곤란한 현상일 발생하는 현상 번다운 차트 : 남은 작업량을 시간에 따라 표시하여 진행 상황을 시각적으로 나타내는 차트 COCOMO : 보헴이 제안한 프로그램 규모에 따라 비용을 산정하는 방식 (조직형, 분리형, 임베디드형) CPM : 프로젝트의 작업을 네트워크 형태로 표현하여 전체 프로젝트의 일정을 계산하는 알고리즘 PERT : 비관치, 중관치, 낙관치의 3점 추정 방식을 통해 일정을 관리하는 기법 결함 집중 : 20%의 모듈에서 80%의 결함이 발생한다는 원리 살충제 패러독스 : 동일한 테스트 케이스를 반복적으로 실행하면 새로운 결함을 발견하지 못한다는 원리 배치 다이어그램 : 시스템의 물리적인 구조를 보여주는 다이어그램, 어떤 SW가 어떤 HW에 배치되는지를 나타냄 패키지 다이어그램 : 시스템의 패키지 구조를 나타내는 다이어그램 브룩스의 법칙 : &amp;ldquo;늦어진 프로젝트에 인력을 추가하면 오히려 더 늦어진다&amp;quot;는 법칙 네트워크 관련 개념 Hub &amp;amp; Spoke : EAI 구축 유형; 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식 MQTT : IoT 장치 간 통신에 사용되는 경량 메시징 프로토콜 CoAP : M2M 노드들 사이에서 이벤트에 대한 송수신을 비동기적으로 전송하는 REST 기반의 프로토콜 거리 벡터 알고리즘 : 네트워크 라우팅 프로토콜의 한 종류; 각 노드가 자신의 거리와 이웃 노드의 거리 정보를 교환하여 최적 경로를 찾는 알고리즘 링크 상태 알고리즘 : 네트워크 라우팅 프로토콜의 한 종류; 각 노드가 전체 네트워크의 상태 정보를 수집하여 최적 경로를 찾는 알고리즘 회선 제어 : 두 개의 스테이션이 동시에 신호를 전송하는 경우 충돌이 발생하지 않도록 제어하는 기술 Slowris : 다량의 HTTP 연결을 동시에 열고 유지하는 DoS RUDY : 느린 속도로 양식 데이터를 제출하여 연결 상태를 유지하는 것을 목표로 하는 DoS Slow Http read Dos : HTTP 요청 패킷의 헤더를 변조하여 웹 서버에 보내 연결 상태를 유지하게 하는 DoS SNMP(Simplified Network Management Protocol) : 네트워크 장비의 상태를 모니터링하고 관리하기 위한 프로토콜 DHCP(Dynamic Host Configuration Protocol) : 네트워크 장치에 IP 주소를 자동으로 할당하는 프로토콜 RARP (Reverse Address Resolution Protocol) : MAC 주소 -&amp;gt; IP 주소 변환 프로토콜 보안 관련 개념 kill switch : 스마트폰 이용자가 도난당한 스마트폰의 작동을, 웹사이트를 통해 정지할 수 있도록 하는 일종의 자폭 기능 제로 데이 공격 : 보안 취약점이 알려지기 전에 해당 취약점을 악용하여 이루어지는 공격 ARP Spoofing : ARP 프로토콜을 이용하여 네트워크 상의 다른 호스트의 MAC 주소를 위조하는 공격 기법 디지털 포렌식 : 디지털 기기에서 발생한 범죄나 사고의 증거를 수집, 분석, 보존하는 과정 루트킷 : 시스템에 몰래 설치되어 사용자의 권한을 탈취하거나 시스템을 제어하는 악성 소프트웨어 스피어 피싱 : 특정 개인이나 조직을 대상으로 하는 맞춤형 피싱 공격 APT 공격 : 특정 타깃을 목표로 다양한 수단을 통한 지속적이고 지능적인 맞춤혐 공격 기법 SET(Secure Electronic Transaction) : 전자 상거래에서 안전한 결제를 위한 프로토콜 사이버 킬체인 : 록히드 마틴의 공격형 방위 시스템 DAC (Discretionary Access Control) : 사용자가 자유롭게 객체에 대한 접근 권한을 관리할 수 있는 방식 MAC (Mandatory Access Control) : 시스템 관리자가 정책에 따라 사용자에게 접근 권한을 부여하는 방식 데이터베이스 관련 개념 낙관적 검증 : 트랜잭션을 일단 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스 반영하는 기법 2PC (Two-Phase Commit) : 분산 데이터베이스 시스템에서 트랜잭션의 원자성을 보장하기 위해 두 단계로 커밋을 수행하는 방식 완전 함수 종속 : 릴레이션의 모든 속성이 기본키에만 종속되는 상태 이행 함수 종속 : A-&amp;gt;B, B-&amp;gt;C 이면 A-&amp;gt;C가 성립하는 상태 체크포인트 회복 기법 : 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애를 복구하는 기법 OS 관련 개념 마이크로커널 : 다양한 서비스를 Kernel Mode가 아닌 User Mode에서 처리하는 초소형 커널 프로세스 스케쥴링 SJF(Shortest Job First) : 가장 짧은 작업을 먼저 처리하는 방식 HRN (Highest Response Ratio Next) : 대기 시간과 서비스 시간을 고려하여 우선순위를 결정하는 방식 피터슨 알고리즘 : 두 프로세스 간의 상호 배제를 보장하는 알고리즘; 플랙그와 턴을 사용하여 상호 배제와 진입 허용을 구현 기타 개념 피코넷 : 여러 개의 독립된 장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술 지그비 :저속 전송 속도를 갖는 홈오토메이션 및 데이터 네트워크를 위한 표준 기술 클리어링 하우스 : 디지털 저작권 라이선싱을 중개하고 라이선스 발급을 수행하는 정산소 데이터 마트 : 데이터의 한 부분으로서 특정 사용자가 관심을 갖는 데이터들을 담은 비교적 작은 규모의 데이터 웨어하우스 OLAP : 온라인 분석 처리; 데이터 웨어하우스의 데이터를 전략적인 정보로 변환시켜서 의사결정을 지원하는 역할 수행 semantic web : 웹 상의 정보에 의미를 부여하여 기계가 이해할 수 있도록 하는 기술 온톨로지(Ontology) : 특정 도메인에 대한 개념과 그들 간의 관계를 정의하는 명세 디지털 아카이빙 : 디지털 자료를 장기적으로 보존하고 관리하는 과정 CEP(Complex Event Processing) : 실시간으로 대량의 이벤트를 처리하고 분석하는 기술 노모포비아 : 스마트폰을 잃어버리거나 사용할 수 없는 상황에 대한 불안감 ITIL(Information Technology Infrastructure Library) : 영국 정부가 다양한 IT 서비스들의 관리 방법들을 모아 만든 표준적인 참고 문서 데이터 마이닝 : 대량의 데이터에서 유용한 정보를 추출하는 과정 오픈 스택 : 아파치 라이선스로 배포되는 클라우드 플랫폼 프로젝트 BCP(Business Continuity Planning) : 재해 발생 시 비즈니스 운영을 지속하기 위한 계획 Trust Zone : ARM에서 개발한 보안 기술로, 하드웨어 기반의 보안 영역을 제공하여 민감한 데이터를 보호하는 기술 WSDL (Web Services Description Language) : 웹 서비스의 기능을 기술하는 XML 기반의 언어 EAI : 기업 내 다양한 시스템 간의 데이터 통합 및 상호 운용성을 위한 솔루션 SQL LIKE 문법 % : 0개 이상의 문자열과 일치 [ ] : 1개의 문자와 일치 [^ ] : 1개의 문자와 불일치 _ : 특정 위치의 1개 문자와 일치</description></item><item><title>정보처리기사 필기 준비</title><link>https://bong-u.github.io/til/etc/ipe_written/</link><pubDate>Wed, 07 May 2025 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/ipe_written/</guid><description>1과목 : 소프트웨어 설계 결합도 자료 결합도 : 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도 스탬프 결합도 : 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도 제어 결합도 : 한 모듈이 다른 모듈과 제어 신호를 이용하여 통신하고, 공유되는 공통 데이터 영역을 사용할 때의 결합도 외부 결합도 : 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도 공유 결합도 : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 내용 결합도 : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도 응집도 순차적 응집도 (Sequential Cohesion) 교환적 응집도 (Communicational Cohesion) 절차적 응집도 (Procedural Cohesion) 시간적 응집도 (Temporal Cohesion) 논리적 응집도 (Logical Cohesion) 우연적 응집도 (Coincidental Cohesion) 유스케이스(Use Case)의 구성 요소 간의 관계 연관 관계 포함 관계 확장 관계 일반화 관계 자료흐름도의 각 요소별 표기 형태 Process : 원 Data Flow : 화살표 Data Store : 평행선 Terminator : 사각형 추상화의 종류 자료 추상화 과정 추상화 제어 추상화 UML 모델에서의 관계 Aggregation : 집합 관계 Generalization : 일반화 관계 Composition : 포함 관계 Dependency : 의존 관계 Realization : 실체화 관계 2과목 : 소프트웨어 개발 법칙 파레토 법칙 : 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙 해싱함수 종류 제산법, 제곱법, 폴딩법, 기수 변환법, 대수적 코딩법, 계수 분석법(숫자 분석법), 무작위법</description></item><item><title>최신컴퓨터특강</title><link>https://bong-u.github.io/til/school/%EC%B5%9C%EC%8B%A0%EC%BB%B4%ED%93%A8%ED%84%B0%ED%8A%B9%EA%B0%95/</link><pubDate>Mon, 14 Apr 2025 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/%EC%B5%9C%EC%8B%A0%EC%BB%B4%ED%93%A8%ED%84%B0%ED%8A%B9%EA%B0%95/</guid><description>1주차 - 원유재 교수님 - 첨단분야 혁신융합대학사업 (COSS: Convergence and Open Sharing System) 추진배경 : 디지털 전환, 글로벌 경쟁 심화에 따라 신기술 초격차 확보 및 급증하는 신산업 인력 수요에 대응할 수 있는 인재 양성 충남대학교 : 블록체인 분야 특화, 연구협력(연구단지) 중심 특화 5개 융복합창의전공 블록체인융합전공 사이버보안융합전공 클라우드융합전공 데이터보안활용융합전공 : 컴퓨터 비전공자 대상 개인정보보호융합전공 25-1학기 충남대학교 개설 과목 블록체인 개론 블록체인 프로그래밍 디지털 자산과 블록체인 학생지원 혁신융합대학 학위 취득 장학금 지원 전문가와 교류 기회 학습기기 지원 현장실습 기회 3주차 - 김형신 교수님 AI기술의 임베디드 시스템화 이유 Privacy (개인정보 보호) Latency (지연시간) Cost (비용) Embedding Resnet Resnet을 임베디드 시스템에 적용함</description></item><item><title>JIT 컴파일러와 AOT 컴파일러</title><link>https://bong-u.github.io/til/java/jit_aot/</link><pubDate>Mon, 16 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/jit_aot/</guid><description>JIT(Just-In-Time) 컴파일러 프로그램이 실행 중일때, 바이트 코드를 네이티브 코드로 컴파일하는 컴파일러
주요 작업 Hotspot(자주 실행되는 코드)을 탐지 최적화 수준 결정 최적화 및 컴파일 네이티브 코드 생성 캐싱 : 네이티브 코드를 캐싱하여 재사용 AOT(Ahead-Of-Time) 컴파일러 프로그램이 실행되기 전에, 바이트 코드를 네이티브 코드로 컴파일하는 컴파일러
인터프리터 방식 X, 컴파일 방식 O 실행 속도가 빠름 GraalVM을 사용하면 Java 프로그램을 AOT 컴파일 가능 GraalVM 오라클에서 개발한 JVM 기반의 다양한 언어를 지원하는 통합 실행 환경 (JVM, JDK)</description></item><item><title>Python의 동작 원리</title><link>https://bong-u.github.io/til/python/interpreter/</link><pubDate>Mon, 16 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/interpreter/</guid><description>파이썬의 구현체 CPython 파이썬의 표준 구현체이자 인터프리터
역할 파이썬 코드를 바이트 코드로 변환 바이트 코드를 실행 파이썬 바이트 코드 .pyc 파일에 저장 플랫폼에 독립적 파이썬 가상 머신(PVM)에서 실행 예시 4 0 LOAD_GLOBAL 0 (print) 2 LOAD_CONST 1 ('hello world') 4 CALL_FUNCTION 1 6 POP_TOP 5 8 LOAD_CONST 2 (True) 10 RETURN_VALUE Jython 파이썬 코드를 자바 바이트 코드로 변환, JVM에서 실행</description></item><item><title>DDD(Domain Driven Design)</title><link>https://bong-u.github.io/til/spring/ddd/</link><pubDate>Fri, 13 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/ddd/</guid><description>도메인 패턴을 중심으로 설계하는 방법론
IOC 객체의 제어권을 개발자가 아닌 프레임워크 또는 외부 컨테이너에게 넘기는 것
목적 객체 간 결합도를 감소 -&amp;gt; 유연성, 재사용성 증가 구현하는 기법 DI(Dependency Injection) Constructor Injection Setter Injection Field Injection DL(Dependency Lookup) Service Locator Event-based callback DI(Dependency Injection) 객체 간의 의존 관계를 객체 자신이 아닌 외부에서 주입하는 것
장점 객체 간 결합도 감소 테스트 용이성 증가 객체의 책임이 명확하고 단순함 단점 초기 설정, 구현이 복잡함 객체 생성 시점에 의존 객체가 없으면 에러 발생 DL(Dependency Lookup) 객체 간의 의존 관계를 객체 자신이 아닌 외부에서 찾아오는 것</description></item><item><title>JVM(Java Virtual Machine)</title><link>https://bong-u.github.io/til/java/jvm/</link><pubDate>Fri, 13 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/jvm/</guid><description> 자바 바이트 코드를 실행할 수 있는 가상 머신
JVM의 구조 클래스 로더 (Class Loader) 로딩 (Loading) : .class 파일을 읽어들여 메모리에 적재 링크 (Linking) : 적재된 클래스의 참조를 확인하고 준비 초기화 (Initialization) : static 블록과 static 변수 초기화 실행 엔진 (Execution Engine) 클래스 로더가 메모리에 적재된 바이트 코드를 실행하는 역할 인터프리터 (Interpreter) 바이트 코드를 명령어 단위로 읽어서 실행 JIT 컴파일러 (Just-In-Time Compiler) Runtime 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경 후 실행 -&amp;gt; 성능 향상 GC (Garbage Collector) 더 이상 사용하지 않는 메모리를 해제하는 역할 런타임 데이터 영역 (Runtime Data Area) PC(Program Counter) 스레드가 실행되는 부분의 주소를 가리키는 포인터 JVM 스택 (JVM Stack) 메소드 호출 시마다 프레임을 추가하고, 메소드가 종료되면 해당 프레임을 제거 각 프레임은 로컬 변수, 연산 스택, 메소드 수행이 끝나면 종료되는 정보를 저장 Native 메소드 스택 JNI(Java Native Interface)를 통해 호출되는 C/C++/Assembly와 같은 네이티브 코드를 위한 스택 힙 (Heap) new 키워드로 생성된 객체와 배열을 저장하는 공간 메소드 영역 (Method Area) 클래스 정보, 상수, 정적 변수 등을 저장하는 공간 모든 쓰레드가 공유하는 공간 -&amp;gt; 멀티쓰레딩 시 동기화 처리 필요</description></item><item><title>Python의 GIL</title><link>https://bong-u.github.io/til/python/gil/</link><pubDate>Fri, 13 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/gil/</guid><description>GIL(Global Interpreter Lock) 하나의 쓰레드만 파이썬 바이트코드를 실행할 수 있도록 하는 것
파이썬의 표준 구현인 CPython에서만 존재 장점 Reference Counting 기반 메모리 관리의 Race condition 방지 데이터 무결성 보장 : 멀티쓰레드 환경에서 파이썬 객체나 메모리 관련 작업이 안전하게 수행되도록 보장 파이썬 Interpreter의 구현을 단순화 : 복잡한 락 메커니즘이 필요없음 C 확장 모듈이 Thread-Safe 하지 않더라도 안전하게 사용할 수 있도록 보장 플랫폼 독립성 유지 : CPU 아키텍처별 동기화 메커니즘에 의존하지 않음 단점 멀티코어 CPU 활용 제한: 단일 코어만 사용되므로 병렬 처리의 이점을 얻을 수 없음 멀티쓰레딩 성능 저하 : 쓰레드 간 context switching이 빈번하게 발생 공정성 문제 : 특정 쓰레드가 GIL을 장시간 점유하면 starvation 문제가 발생할 수 있음 Reference Counting 객체가 몇 번 참조되는지를 세어서 0이 되면 메모리를 해제하는 방식</description></item><item><title>Github Readme Stats - private 레포지토리도 포함하기</title><link>https://bong-u.github.io/til/etc/gh_readme_stats_deploy/</link><pubDate>Thu, 05 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/gh_readme_stats_deploy/</guid><description>배경 github에서 자신이 어떤 언어를 주로 쓰는지 통계를 주는 Readme를 본 기억이 나서 나도 만들어보고 싶었다. anuraghazra/github-readme-stats를 참고하여 README.md에 추가하였다. 그러나 preview를 해보았을 때, typescript가 절반으로 나오는 것이다. 말이 안되는 수치라서 알아보니, public 레포지토리만 포함되어 그런 것이었다. private 레포지토리도 통계에 포함하기 위한 방법을 설명하겠다. 방법 maintainer가 배포해놓은 서비스는 나의 private 레포지토리에 접근할 수 없다. private repository도 포함한 통계를 보기 위해서는 직접 배포해야 한다고 한다. 익숙한 Github Pages로 배포하려고 했으나, 동적으로 처리하는 부분이 있어서 Vercel로 배포하였다.</description></item><item><title>Express&amp;React 프로젝트에 Recaptcha v3 적용하기</title><link>https://bong-u.github.io/til/javascript/apply_recaptcha/</link><pubDate>Tue, 03 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/apply_recaptcha/</guid><description>상황 사이드 프로젝트 &amp;ldquo;알록&amp;quot;을 개발하던 중, 사용자가 악의적인 목적으로 반복적으로 요청을 보내는 것을 어떻게 막을까 고민하게 되었다. 조사를 통해 Google에서 제공되는 Recaptcha를 사용하면 손쉽게 방지할 수 있다는 것을 알게 되었다. 공격자의 입장에서 생각했을 때, 지금 프로젝트에서 가장 취약한 부분은 회원가입이라고 생각했다. 회원가입은 회원이 아닌 자가, 아이디와 비밀번호 규칙만 만족한다면 반복적으로 요청을 보낼 수 있고, 이는 DB에 바로 저장되기 때문이다. 따라서 회원가입 부분에 Recaptcha를 적용하기로 결정했다. Recaptcha란? Recaptcha는 구글에서 제공하는 무료 보안 서비스로, 사용자가 로봇이 아님을 증명하는 방법 중 하나이다.</description></item><item><title>Issue - Gihub action 오류 - venv 적용</title><link>https://bong-u.github.io/til/etc/gh_action_issue2/</link><pubDate>Mon, 25 Nov 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/gh_action_issue2/</guid><description>문제상황 TIL 블로그 자동 배포 github action이 잘 작동하다가 실패한다. 에러로그 1error: externally-managed-environment 2 3× This environment is externally managed 4╰─&amp;gt; To install Python packages system-wide, try apt install 5 python3-xyz, where xyz is the package you are trying to 6 install. 7 8 If you wish to install a non-Debian-packaged Python package, 9 create a virtual environment using python3 -m venv path/to/venv. 10 Then use path/to/venv/bin/python and path/to/venv/bin/pip.</description></item><item><title>Issue - Gihub action 오류 - yaml multiline</title><link>https://bong-u.github.io/til/etc/gh_action_issue1/</link><pubDate>Mon, 25 Nov 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/gh_action_issue1/</guid><description>문제상황 TIL 블로그 자동 배포 github action이 잘 작동하다가 실패한다. 에러 로그에는 python 라이브러리가 설치되지 않았다는 내용이 적혀있었다. 문제의 yaml 코드 1- name: Install dependencies 2 run: python -m pip install --upgrade pip 3 pip install -r requirements.txt 해결방법 fix: github action error - &amp;ldquo;Could not find a version&amp;rdquo; 하단의 pip install 명령어가 실행되지 않아 오류가 발생하는것으로 판단하였다. literal 방식으로 pipe(|)를 사용하여 두번째 줄의 명령어가 실행되도록 수정하였다. 1- name: Install dependencies 2 run: |3python -m pip install --upgrade pip 4pip install -r requirements.</description></item><item><title>백준 - 20125 : 쿠키의 신체 측정 (S4)</title><link>https://bong-u.github.io/til/algorithm/boj_20125/</link><pubDate>Fri, 15 Nov 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_20125/</guid><description>1#include &amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3 4char board[1000][1000] = { NULL }; 5int n; 6 7tuple&amp;lt;int, int, int&amp;gt; getlength(int sx, int sy, int dx, int dy) { 8 int cnt = 0; 9 int x = sx; 10 int y = sy; 11 12 while (true) { 13 x += dx; 14 y += dy; 15 if (y &amp;lt; 0 || y &amp;gt;= n || x &amp;lt; 0 || x &amp;gt;= n || board[x][y] !</description></item><item><title>백준 - 8979 : 올림픽 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_8979/</link><pubDate>Fri, 15 Nov 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_8979/</guid><description>1#include &amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3 4struct medal { 5 int number; 6 int gold; 7 int silver; 8 int bronze; 9}; 10bool cmp(medal a, medal b) { 11 if (a.gold != b.gold) return a.gold &amp;gt; b.gold; 12 if (a.silver != b.silver) return a.silver &amp;gt; b.silver; 13 return a.bronze &amp;gt; b.bronze; 14 15} 16int main() { 17 cin.tie(0)-&amp;gt;sync_with_stdio(false); 18 int n = 0, target = 0, rank = 0; 19 cin &amp;gt;&amp;gt; n; 20 cin &amp;gt;&amp;gt; target; 21 22 medal* arr = new medal[n]; 23 24 for (int i = 0; i &amp;lt; n; i++) { 25 cin &amp;gt;&amp;gt; arr[i].</description></item><item><title>C++ 개념 정리</title><link>https://bong-u.github.io/til/c_cpp/cpp_concept/</link><pubDate>Thu, 10 Oct 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/c_cpp/cpp_concept/</guid><description>본 내용은 2023 MISRA-CPP 가이드라인을 공부하면서 개념을 정리한 것이다.
참조(Reference)와 포인터(Pointer) 포인터(Pointer) 메모리 주소를 저장하는 변수
1// 변수 선언 2int a = 10; 3int* b = &amp;amp;a; // a의 주소를 저장 4 5// 매개변수로 전달 6void add(int* a, int* b) { 7 *a + *b; 8} 9 10add(&amp;amp;a, &amp;amp;b); 참조(Reference) 변수에 별칭을 부여하는 것
이름으로 대상을 가리킨다.
제약사항
참조는 선언과 동시에 초기화해야 한다.</description></item><item><title>C언어 개념 정리</title><link>https://bong-u.github.io/til/c_cpp/c_concept/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/c_cpp/c_concept/</guid><description>본 내용은 2023 MISRA-C 가이드라인을 공부하면서 개념을 정리한 것이다.
dead code &amp;lt;-&amp;gt; unreachable code dead code : 코드에서 실행되지만 그 결과가 다른 계산에 사용될 수 없는 섹션 unreachable code : 제어 흐름 경로가 없기 때문에 실행할 수 없는 프로그램 소스 코드의 일부 tag struct, union, enum 뒤에 붙는 이름 escape sequence 백슬래시()와 특정문자를 결합하여 표현하기 어려운 기능, 문자를 표시해준다. 종류 (대표적인 것만 몇개 뽑았다) \n : 개행 \t : 수평 탭 \o(8진수 숫자) : 8진수 \x(16진수 숫자) : 16진수 연결 다른 범위에 속하는 변수들을 서로 연결하는 것</description></item><item><title>소프트웨어 테스트</title><link>https://bong-u.github.io/til/etc/testing/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/testing/</guid><description>내부 구조를 고려하는지 여부에 따른 테스트의 분류 블랙박스 테스트 화이트박스 테스트 목적과 범위에 따른 테스트의 분류 수행 순서에 따라 작성해보았다. 1. 단위 테스트 (Unit Test) 가장 작은 단위 수준(모듈, 함수, 클래스)의 테스트
2. 통합 테스트 (Integration Test) 모듈을 통합하는 과정에서, 각 모듈 간의 인터페이스와 관련된 결함이 있는지 테스트
Top-down : 상위 모듈부터 하위 모듈로 통합하며 테스트 Bottom-up : 하위 모듈부터 상위 모듈로 통합하며 테스트 Big-bang : 모든 모듈을 한번에 통합하여 테스트 Threads : 중요 모듈을 먼저 구현하고 통합한 뒤, 보조적인 모듈을 구현 후 통합하는 방식 3.</description></item><item><title>[모각코24하계] 06 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-2-06/</link><pubDate>Wed, 14 Aug 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-06/</guid><description>배경 테커 부트캠프 최종발표 전날이다. gpt 프롬프트 부분 수정을 main 브랜치에 반영하고, EC2 서버에 배포했다. 문제 배포한 서버에서 websocket 연결이 404 에러를 반환한다. (내일이 최종 발표인데,,,) 다른 http 요청은 정상적으로 처리되지만 웹소켓만 처리되지 않는 것을 확인했다. nginx의 log 1{IP주소} - - [02/Aug/2024:10:59:04 +0000] &amp;#34;GET /ws/chatrooms/294?user_id=296 HTTP/1.1&amp;#34; 404 22 &amp;#34;-&amp;#34; &amp;#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Safari/605.1.15&amp;#34; 2{IP주소} - - [02/Aug/2024:10:59:05 +0000] &amp;#34;GET /ws/chatrooms/294?</description></item><item><title>[모각코24하계] 05 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-2-05/</link><pubDate>Sun, 04 Aug 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-05/</guid><description>배경 테커 부트캠프를 진행중이다. 모든 프로그램은 docker-compose로 구성되어 있다. AWS EC2에 구동 중인 서버에 HTTPS를 적용하려고 한다. 도메인 구매 없이 시도를 했으나, AWS에서 제공하는 도메인으로 SSL 인증서를 발급받을 수 없었다. 따라서, 도메인을 구매하고, Route 53을 통해 도메인을 연결했다. 목표 Nginx를 이용하여 HTTPS를 적용한다. 방법 1. docker-compose.yml에 certbot 컨테이너를 추가한다. 1certbot: 2 image: certbot/certbot 3 container_name: certbot 4 volumes: 5 - ./certbot/conf:/etc/letsencrypt 6 - ./certbot/www:/var/www/certbot 7 depends_on: 8 - nginx 9 10 # certbot을 무한루프로 돌리기 위해 사용 11 entrypoint: &amp;#34;/bin/sh -c &amp;#39;trap exit TERM; while :; do sleep 6h &amp;amp; wait $${!</description></item><item><title>[모각코24하계] 05 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-2-05plan/</link><pubDate>Sun, 04 Aug 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-05plan/</guid><description>오늘의 목표 Nginx에서 HTTPS 설정하기</description></item><item><title>[모각코24하계] 06 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-2-06plan/</link><pubDate>Sun, 04 Aug 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-06plan/</guid><description>오늘의 목표 웹소켓 연결 에러 해결하기</description></item><item><title>Issue - fastapi에서 websocket 404 문제</title><link>https://bong-u.github.io/til/python/issue_websocket/</link><pubDate>Fri, 02 Aug 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/issue_websocket/</guid><description>배경 테커 부트캠프 최종발표 전날이다. gpt 프롬프트 부분 수정을 main 브랜치에 반영하고, EC2 서버에 배포했다. 문제 배포한 서버에서 websocket 연결이 404 에러를 반환한다. (내일이 최종 발표인데,,,) 다른 http 요청은 정상적으로 처리되지만 웹소켓만 처리되지 않는 것을 확인했다. nginx의 log 1{IP주소} - - [02/Aug/2024:10:59:04 +0000] &amp;#34;GET /ws/chatrooms/294?user_id=296 HTTP/1.1&amp;#34; 404 22 &amp;#34;-&amp;#34; &amp;#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Safari/605.1.15&amp;#34; 2{IP주소} - - [02/Aug/2024:10:59:05 +0000] &amp;#34;GET /ws/chatrooms/294?</description></item><item><title>Nginx에서 HTTPS 설정하기</title><link>https://bong-u.github.io/til/devtools/nginx_https/</link><pubDate>Thu, 25 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/devtools/nginx_https/</guid><description>배경 테커 부트캠프를 진행중이다. 모든 프로그램은 docker-compose로 구성되어 있다. AWS EC2에 구동 중인 서버에 HTTPS를 적용하려고 한다. 도메인 구매 없이 시도를 했으나, AWS에서 제공하는 도메인으로 SSL 인증서를 발급받을 수 없었다. 따라서, 도메인을 구매하고, Route 53을 통해 도메인을 연결했다. 목표 Nginx를 이용하여 HTTPS를 적용한다. 방법 1. docker-compose.yml에 certbot 컨테이너를 추가한다. 1certbot: 2 image: certbot/certbot 3 container_name: certbot 4 volumes: 5 - ./certbot/conf:/etc/letsencrypt 6 - ./certbot/www:/var/www/certbot 7 depends_on: 8 - nginx 9 10 # certbot을 무한루프로 돌리기 위해 사용 11 entrypoint: &amp;#34;/bin/sh -c &amp;#39;trap exit TERM; while :; do sleep 6h &amp;amp; wait $${!</description></item><item><title>Fastapi - 통합테스트 In-Memory DB에서 테이블이 없다는 문제</title><link>https://bong-u.github.io/til/python/fastapi_db_test/</link><pubDate>Mon, 22 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/fastapi_db_test/</guid><description>상황 테커 부트캠프에서 팀프로젝트를 진행 중이다. 단위테스트 코드는 작성이 완료되었고, 통합테스트 코드를 작성 중이다. sqlite in-memory db를 사용해서 테스트 중인데, 테이블이 없다는 에러가 발생했다. 테스트 전에 테이블을 생성하는 코드가 실행됨에도 불구하고, 에러가 발생한다. 인메모리가 아닌 파일로 저장하는 방법을 사용하면 에러가 발생하지 않는 것을 보고 문제의 원인을 파악할 수 있었다. 코드 1from database import Base, engine 2from fastapi.testclient import TestClient 3 4from main import app 5from models import * 6 7# 테이블을 생성하는 코드이다 8Base.</description></item><item><title>[모각코24하계] 04 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-2-04/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-04/</guid><description>배경 테커 부트캠프에서 팀프로젝트를 진행 중이다. 현재 비즈니스 로직을 수행하는 함수를 대상으로 Unit Test가 필요하다. Unit Test 코드를 작성하고, Github Actions를 이용하여 자동으로 테스트가 수행되도록 설정하고자 한다. run-pytest.yml 1name: Run pytest 2 3# main 또는 dev 브랜치에 pull request가 발생하면 실행 4on: 5 pull_request: 6 branches: 7 - main 8 - dev 9 10jobs: 11 test: 12 runs-on: ubuntu-latest 13 14 steps: 15 - name: Checkout code 16 uses: actions/checkout@v2 17 18 - name: Set up Python 19 uses: actions/setup-python@v2 20 with: 21 python-version: &amp;#39;3.</description></item><item><title>[모각코24하계] 04 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-2-04plan/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-04plan/</guid><description>오늘의 목표 Github Actions를 이용하여 pytest 자동화 테스트 환경 구축</description></item><item><title>Github Actions에서 pytest 실행하기</title><link>https://bong-u.github.io/til/python/github_action_pytest/</link><pubDate>Wed, 17 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/github_action_pytest/</guid><description>배경 테커 부트캠프에서 팀프로젝트를 진행 중이다. 현재 비즈니스 로직을 수행하는 함수를 대상으로 Unit Test가 필요하다. Unit Test 코드를 작성하고, Github Actions를 이용하여 자동으로 테스트가 수행되도록 설정하고자 한다. run-pytest.yml 1name: Run pytest 2 3# main 또는 dev 브랜치에 pull request가 발생하면 실행 4on: 5 pull_request: 6 branches: 7 - main 8 - dev 9 10jobs: 11 test: 12 runs-on: ubuntu-latest 13 14 steps: 15 - name: Checkout code 16 uses: actions/checkout@v2 17 18 - name: Set up Python 19 uses: actions/setup-python@v2 20 with: 21 python-version: &amp;#39;3.</description></item><item><title>[모각코24하계] 03 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-2-03/</link><pubDate>Tue, 16 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-03/</guid><description>Fastapi, RabbitMQ, Celery 연동 배경 테커 부트캠프에서 팀프로젝트를 진행 중이다. 웹소켓을 통해 클라이언트로부터 받은 데이터를 gpt를 통해 처리하고, 결과를 다시 클라이언트로 보내는 서비스를 구현하고 있다. 여러 사용자의 요청을 원활하게 처리하기 위해 분산 비동기 시스템을 구축하려고 한다. 목표 Fastapi, RabbitMQ, Celery를 각자 docker 컨테이너로 구동시키고 연동한다. docker-compose.yml 1version: &amp;#39;3&amp;#39; 2 3services: 4 rabbitmq: 5 image: rabbitmq:3 6 ports: 7 - &amp;#34;5672:5672&amp;#34; # RabbitMQ의 AMQP 포트 8 - &amp;#34;15672:15672&amp;#34; # RabbitMQ 관리 인터페이스 포트 9 volumes: 10 - rabbitmq_data:/var/lib/rabbitmq 11 expose: 12 - &amp;#34;5672&amp;#34; 13 - &amp;#34;15672&amp;#34; 14 15 celery_worker: 16 build: 17 context: .</description></item><item><title>[모각코24하계] 03 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-2-03plan/</link><pubDate>Tue, 16 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-03plan/</guid><description>오늘의 목표 RabbitMQ, Celery, Fastapi 연동 정리</description></item><item><title>[모각코24하계] 02 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-2-02/</link><pubDate>Thu, 11 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-02/</guid><description>RAG (Retrieval-Augmented Generation) 이론 정리 RAG는 검색과 생성을 결합한 모델로, 검색을 통해 얻은 정보를 바탕으로 생성을 수행하는 모델
LLM의 문제점
할루시네이션: 생성 모델이 훈련 데이터에 없는 내용을 생성하는 현상 최신의 응답을 기대하는 상황에서 오래되었거나 일반적인 정보를 생성하는 문제 신뢰할 수 없는 출처로부터 정보를 생성하는 문제 RAG는 위에서 서술한 LLM 문제의 일부를 해결하기 위해 사용할 수 있는 수단이다.
OpenSearch OpenSearch는 오픈소스 검색 및 분석 엔진으로, 엘라스틱서치의 포크 버전</description></item><item><title>[모각코24하계] 02 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-2-02plan/</link><pubDate>Thu, 11 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-02plan/</guid><description>오늘의 목표 RAG 이론 정리 OpenSearch를 활용한 Rag 적용</description></item><item><title>Fastapi, RabbitMQ, Celery 연동</title><link>https://bong-u.github.io/til/python/fastapi_rabbitmq_celery/</link><pubDate>Thu, 11 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/fastapi_rabbitmq_celery/</guid><description>배경 테커 부트캠프에서 팀프로젝트를 진행 중이다. 웹소켓을 통해 클라이언트로부터 받은 데이터를 gpt를 통해 처리하고, 결과를 다시 클라이언트로 보내는 서비스를 구현하고 있다. 여러 사용자의 요청을 원활하게 처리하기 위해 분산 비동기 시스템을 구축하려고 한다. 목표 Fastapi, RabbitMQ, Celery를 각자 docker 컨테이너로 구동시키고 연동한다. docker-compose.yml 1version: &amp;#39;3&amp;#39; 2 3services: 4 rabbitmq: 5 image: rabbitmq:3 6 ports: 7 - &amp;#34;5672:5672&amp;#34; # RabbitMQ의 AMQP 포트 8 - &amp;#34;15672:15672&amp;#34; # RabbitMQ 관리 인터페이스 포트 9 volumes: 10 - rabbitmq_data:/var/lib/rabbitmq 11 expose: 12 - &amp;#34;5672&amp;#34; 13 - &amp;#34;15672&amp;#34; 14 15 celery_worker: 16 build: 17 context: .</description></item><item><title>OpenSearch를 활용한 RAG 실습</title><link>https://bong-u.github.io/til/ai/rag_opensearch/</link><pubDate>Fri, 05 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/ai/rag_opensearch/</guid><description>배경 테커 부트캠프에서 팀프로젝트를 진행 중이다. 우리 팀의 주제는 특정 인물에게 상담을 받는 것 같은 대화를 할 수 있는 챗봇을 만드는 것이다. 이를 위해 특정 인물이 했던 말을 모아 데이터셋으로 만들고 이를 RAG 모델에 적용시키려고 한다. 순서 일론 머스크가 TED에서 한 인터뷰를 텍스트로 가져온다. OpenSearch 도커 컨테이너를 실행한다. 텍스트 데이터를 임베딩해서 OpenSearch에 저장한다. RAG 모델이 OpenSearch를 쿼리하여 대답을 생성한다. 1. 일론 머스크 인터뷰 텍스트 가져오기 유튜브에서 &amp;ldquo;스크립트 보기&amp;quot;를 통해 인터뷰 자막을 가져온다.</description></item><item><title>RAG 이론 정리 + OpenSearch</title><link>https://bong-u.github.io/til/ai/rag_concept/</link><pubDate>Fri, 05 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/ai/rag_concept/</guid><description>RAG (Retrieval-Augmented Generation) RAG는 검색과 생성을 결합한 모델로, 검색을 통해 얻은 정보를 바탕으로 생성을 수행하는 모델
LLM의 문제점
할루시네이션: 생성 모델이 훈련 데이터에 없는 내용을 생성하는 현상 최신의 응답을 기대하는 상황에서 오래되었거나 일반적인 정보를 생성하는 문제 신뢰할 수 없는 출처로부터 정보를 생성하는 문제 RAG는 위에서 서술한 LLM 문제의 일부를 해결하기 위해 사용할 수 있는 수단이다.
OpenSearch OpenSearch는 오픈소스 검색 및 분석 엔진으로, 엘라스틱서치의 포크 버전</description></item><item><title>[모각코24하계] 01 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-2-01/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-01/</guid><description>django에서 swagger 문서화 구현하기 개요 장고 프레임워크를 사용하여 기본적인 CRUD 기능과, REST API를 구현하는 방법을 알아보자.
프로젝트 구조 1. 2├── db.sqlite3 3├── djtest (메인 앱) 4│ ├── __init__.py 5│ ├── asgi.py 6│ ├── settings.py 7│ ├── urls.py 8│ ├── views.py 9│ └── wsgi.py 10├── manage.py 11├── paste (생성한 앱) 12│ ├── __init__.py 13│ ├── admin.py 14│ ├── apps.py 15│ ├── migrations 16│ ├── models.py 17│ ├── serializers.</description></item><item><title>[모각코24하계] 01 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-2-01plan/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-2-01plan/</guid><description>오늘의 목표 django에서 swagger 문서화 구현하기 django에서 JWT 인증 구현하기</description></item><item><title>Django - JWT 인증</title><link>https://bong-u.github.io/til/python/django_jwt/</link><pubDate>Fri, 28 Jun 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/django_jwt/</guid><description>JWT(Json Web Token)는 웹 표준으로, JSON 객체를 사용하여 정보를 안전하게 전달하는 방식이다.
JWT 인증 구현하기 장고에서는 djangorestframework-simplejwt 패키지를 사용하여 JWT 인증을 구현할 수 있다.
requirements 1pip install djangorestframework-simplejwt settings.py 1INSTALLED_APPS = [ 2 ... 3 &amp;#39;rest_framework&amp;#39;, 4 &amp;#39;rest_framework_simplejwt&amp;#39;, 5] 1REST_FRAMEWORK = { 2 # 기본 인증 클래스를 설정 3 &amp;#39;DEFAULT_AUTHENTICATION_CLASSES&amp;#39;: ( 4 &amp;#39;rest_framework_simplejwt.authentication.JWTAuthentication&amp;#39;, 5 ), 6 # 기본 스키마 클래스를 설정, CoreAPI를 사용하여 자동으로 API 문서화를 생성 7 &amp;#39;DEFAULT_SCHEMA_CLASS&amp;#39;: &amp;#39;rest_framework.</description></item><item><title>Django - crud 기초</title><link>https://bong-u.github.io/til/python/django_basic/</link><pubDate>Wed, 26 Jun 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/django_basic/</guid><description>개요 장고 프레임워크를 사용하여 기본적인 CRUD 기능과, REST API를 구현하는 방법을 알아보자.
프로젝트 구조 1. 2├── db.sqlite3 3├── djtest (메인 앱) 4│ ├── __init__.py 5│ ├── asgi.py 6│ ├── settings.py 7│ ├── urls.py 8│ ├── views.py 9│ └── wsgi.py 10├── manage.py 11├── paste (생성한 앱) 12│ ├── __init__.py 13│ ├── admin.py 14│ ├── apps.py 15│ ├── migrations 16│ ├── models.py 17│ ├── serializers.py 18│ ├── tests.py 19│ ├── urls.</description></item><item><title>Git - Submodule</title><link>https://bong-u.github.io/til/devtools/git_submodule/</link><pubDate>Tue, 25 Jun 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/devtools/git_submodule/</guid><description>Git Submodule 레포지토리 하위에 다른 저장소를 관리하기 위한 도구
용어 슈퍼 프로젝트 : 상위 레포지토리 서브 모듈 : 하위 레포지토리 명령어 super-repository의 “dirA” 라는 디렉토리에 sub-repository를 등록하는 경우
1$ git submodule add https://github.com/bong-u/sub-repository.git dirA sub-repository의 변경상황을 반영해야하는 경우
1# 1번째 방법 : sub-repository내에서 pull 해야한다 2$ cd dirA 3$ git pull 4# 2번째 방법 5$ git submodule update --remote 서브모듈을 포함한 프로젝트 클론하기</description></item><item><title>네트워크 보안</title><link>https://bong-u.github.io/til/school/network_security/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/network_security/</guid><description>네트워크 보안 개요 네트워크 보안의 요구사항 기밀성(Confidentiality) 정보를 권한이 없는 개인에게 노출되지 않도록 함
무결성(Integrity) 정보와 프로그램은 인가된 방식으로만 변경되도록 함
가용성(Availability) 정보 자산에 대해 적절한 시간에 접근 가능하도록 함
보안 공격의 종류 소극적 공격(Passive Attack) 정보를 도청하거나 감시하는 공격 방어방법 : 암호화 적극적 공격(Active Attack) 정보를 변조하거나 삭제하는 공격 방어방법 : 메시지 인증 보안 서비스 인증(Authentication) 사용자의 신원을 확인하는 과정</description></item><item><title>프론트엔드(react) 면접 준비</title><link>https://bong-u.github.io/til/javascript/react_interview/</link><pubDate>Mon, 27 May 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/react_interview/</guid><description>React의 특징 Component 기반 Virtual DOM JSX 단방향 데이터 흐름 생명주기 메소드 Hooks DOM HTML element를 tree형태로 표현한 것
Virtual DOM DOM을 직접 조작하지 않고, 가상의 DOM을 만들어서 조작한 후, 실제 DOM과 비교하여 변경된 부분만 업데이트하는 방식
Diffing : 이전 Virtual DOM과 현재 Virtual DOM을 비교 Reconciliation : 변경된 부분만 실제 DOM에 반영 Batch Update : 여러 개의 변경사항을 한번에 업데이트 React Component Class Component 생명주기 메소드를 포함 상속을 통해 Component를 생성 mutable state를 가질 수 있음 Functional Component immutable하다 stateless Hooks를 사용 LifeCycle Method Mounting constructor : 컴포넌트 생성자 static getDerivedStateFromProps : props로 state를 설정 render : 컴포넌트 렌더링 componentDidMount : 컴포넌트가 마운트된 직후 Updating static getDerivedStateFromProps : props로 state를 설정 shouldComponentUpdate : 컴포넌트 업데이트 여부 결정 render : 컴포넌트 렌더링 getSnapshotBeforeUpdate : 컴포넌트 업데이트 직전 componentDidUpdate : 컴포넌트 업데이트 직후 Unmounting componentWillUnmount : 컴포넌트가 언마운트되기 직전 React Hooks 함수형 컴포넌트에서 state와 생명주기 메소드를 사용할 수 있게 해주는 기능</description></item><item><title>SQLD 대비 정리</title><link>https://bong-u.github.io/til/school/sqld/</link><pubDate>Thu, 09 May 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/sqld/</guid><description>과목 1 : 데이터 모델링의 이해 데이터 모델링을 할때 유의 사항 중복 : 여러 장소에 같은 정보 X 비유연성 : 데이터의 정의와 사용 프로세스를 분리 -&amp;gt; 데이터가 적게 변화되도록 비일관성 : 데이터 간의 상호 연관관계를 명확히 정의 데이터 모델링의 종류 개념적 데이터 모델링 물리적 데이터 모델링 데이터 베이스 모델링의 특징 추상화, 단순화, 명확화
데이터베이스 스키마의 구조 외부 스키마 : 사용자 관점의 데이터베이스 구조 개념 스키마 : 전체 데이터베이스의 논리적 구조 내부 스키마 : 물리적 저장장치에 대한 데이터베이스 구조 엔터티의 특징 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야한다.</description></item><item><title>프로그래밍언어개론</title><link>https://bong-u.github.io/til/school/plt/</link><pubDate>Sun, 14 Apr 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/plt/</guid><description>Ocaml Functional Programming 함수형 프로그래밍은 함수를 값처럼 다루는 프로그래밍 패러다임
특징 Immutable 변수의 값이 변하지 않는다
First-class function Higher-order function Referential transparency 동일한 인자에 대해 항상 동일한 결과를 반환한다
Lazy evaluation (지연 계산) 필요할 때만 계산을 수행
Primitive Types unit int float int_of_float : float-&amp;gt;int float_of_int : int-&amp;gt;float bool : true/false x = y : x equals y (structural equality) x &amp;lt;&amp;gt; y : x not equals y (structural equality) x == y : x equals y (physical equality) x !</description></item><item><title>웹 보안</title><link>https://bong-u.github.io/til/school/web_security/</link><pubDate>Mon, 11 Mar 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/web_security/</guid><description>Web Security Model Web 보안의 목표 Integirty : 무결성 Confidentiality : 기밀성 HTTP URL https:// www.example.edu :80 /lectures ?lec=80 #slides protocol + hostname + port + path + query + fragment
Cookies 서버가 웹 브라우저에게 보내는 정보
역할 : 세션 관리, 사용자 설정 저장, 사용자 추적 등 1// 쿠키 설정 2Set-Cookie: name=value; 3// 쿠키 전송 4Cookie: name=value; Same Origin Policy (SOP) 같은 Origin에서만 리소스를 공유할 수 있도록 한다</description></item><item><title>인간-컴퓨터 상호작용</title><link>https://bong-u.github.io/til/school/human_computer_interface/</link><pubDate>Mon, 04 Mar 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/human_computer_interface/</guid><description>Design Techniques Contextual Inquiry 사용자의 환경에서 사용자의 행동을 관찰 Design Funnel 아이디어를 확장함과 동시에 축소 시킴으로서 결과 도출 Double Diamond Discover -&amp;gt; Define -&amp;gt; Develop -&amp;gt; Deliver Storyboarding 시나리오를 그림으로 표현 Prototyping 디자인을 표현하는 소프트웨어로 구현 종류: Low-fidelity(충실도가 낮음), High-fidelity(충실도가 높음) User Testing In-lab vs On-site Moderated vs Unmoderated : Exploratory vs Assessment Presentation &amp;amp; Communication Needfinding (요구사항 도출) 용어 UI (User Interface) 제품의 시각적인 요소</description></item><item><title>[모각코24동계] 06 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-1-06/</link><pubDate>Wed, 14 Feb 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-06/</guid><description>테스트 기법 블랙박스 기법 개발자와 사용자들의 결험을 바탕으로 기능적 혹은 비기능적 테스트 케이스를 도출하고 선택하는 방법
명세 기반 기법과 경험 기반 기법을 포함 화이트박스 기법 컴포넌트 또는 시스템의 내부 구조를 중심으로 테스트를 도출하는 방법
구조 기반 기법 포함 명세 기반 기법 특징 해결할 문제를 명세하기 위해 모델을 사용한다 모델에서 테스트 케이스를 시스템적으로 도출하는 것이 가능하다 종류 동등 분할 경계값 분석 결정테이블 테스팅 상태전이 테스팅 유즈케이스 테스팅 경험 기반 기법 특징 테스트 관련 인력의 지식이나 경험으로 테스트 케이스를 도출한다 종류 탐색적 테스팅 오류 추정 체크리스트 구조 기반 기법 특징 코드와 개발 설계 등의 소프트웨어 구현 정보를 기반으로 테스트 케이스를 도출한다 종류 구문 테스팅과 커버리지 결정 테스팅과 커버리지 조건 / 결정 커버리지 변경 조건/ 결정 커버리지 다중 조건 커버리지</description></item><item><title>[모각코24동계] 06 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-1-06plan/</link><pubDate>Wed, 14 Feb 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-06plan/</guid><description>오늘의 목표 테스트 기법 종류 정리하기</description></item><item><title>[모각코24동계] 05 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-1-05/</link><pubDate>Tue, 30 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-05/</guid><description>임시 테이블 지역 임시 테이블 (Local Temporary Table) 현재 connection에서만 사용 가능하다 해당 connection이 종료되면 테이블이 자동으로 삭제된다 테이블 이름 앞에 #를 붙여 사용한다 전역 임시 테이블 (Global Temporary Table) 다른 connection에서도 사용 가능하다 마지막 connection이 종료되면 테이블이 사라진다 테이블 이름 앞에 ##를 붙여 사용한다 생성하는 방법 1 - CREATE 사용 1CREATE TABLE #temp ( 2 id INT, 3 name VARCHAR(20) 4) 생성하는 방법 2 - SELECT INTO 사용 1SELECT * 2INTO #temp 3FROM table 특징 인덱스, 제약 조건 등은 복사되지 않는다 SELECT할때 ORDER BY를 사용해도 정렬된 순서대로 저장되지 않는다 LOCK 배타적 잠금 (Exclusive Lock, X) 하나의 특정 트랜잭션만 해당 리소스에 접근할 수 있다</description></item><item><title>[모각코24동계] 05 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-1-05plan/</link><pubDate>Tue, 30 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-05plan/</guid><description>오늘의 목표 MSSQL 임시테이블 정리 MSSQL NOLOCK 정리</description></item><item><title>[모각코24동계] 04 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-1-04/</link><pubDate>Tue, 23 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-04/</guid><description>Recursive Query 1WITH RECURSIVE CTE AS ( 2 SELECT 0 AS A 3 UNION ALL 4 SELECT A+1 AS NUM 5 FROM CTE 6 WHERE A &amp;lt; 10 # 0 부터 10까지 포함 7) 결과 (CTE테이블) A NUM 0 NULL … … 10 NULL 성능 비교 LIMIT 1 VS 서브쿼리 1SELECT PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE 2FROM FOOD_PRODUCT 3ORDER BY PRICE DESC 4LIMIT 1; 1SELECT * 2FROM FOOD_PRODUCT 3WHERE PRICE IN ( 4 SELECT MAX(PRICE) FROM FOOD_PRODUCT 5); LIMIT 1을 사용하는 쿼리는 모든 COLUMN의 데이터를 가져오고, 서브쿼리는 PRICE의 최대값만 가져와서 구하기 때문에, 테이블이 클수록 서브쿼리가 더 빠르다.</description></item><item><title>[모각코24동계] 04 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-1-04plan/</link><pubDate>Tue, 23 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-04plan/</guid><description>오늘의 목표 SQL Recursive Query 공부 SQL 문제 풀면서 배운 것 정리</description></item><item><title>[모각코24동계] 03 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-1-03/</link><pubDate>Wed, 17 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-03/</guid><description>Sub Query 단일 행 서브 쿼리 서브쿼리 결과 : 단일 행 결과 : 단일 행 1SELECT USER_ID, USER_NAME, USER_AGE 2FROM USERS 3WHERE TEAM_ID = ( 4 SELECT TEAM_ID 5 FROM USERS 6 WHERE USER_NAME=&amp;#39;BONG&amp;#39; 7); 다중 행 서브 쿼리 서브쿼리 결과 : 다중 행 결과 : 단일행 다중 행 비교 연산자와 함께 사용 (IN, ALL, ANY, SOME) 1SELECT TEAM_ID, TEAM_NAME, TEAM_LOGO_URL 2FROM TEAM 3WHERE TEAM_ID IN ( 4 SELECT TEAM_ID 5 FROM USERS 6 WHERE USER_NAME=&amp;#39;BONG&amp;#39; 7) 다중 컬럼 서브 쿼리 서브쿼리의 결과: 다중 행 결과 : 다중 행 1SELECT TEAM_ID, USER_NAME 2FROM USERS 3WHERE (TEAM_ID, HEIGHT) 4IN ( 5 SELECT TEAM_ID, MIN(HEIGHT) 6 FROM USERS 7 GROUP BY TEAM_ID 8) 9ORDER BY TEAM_ID, USER_NAME 연관 서브 쿼리 1SELECT B.</description></item><item><title>[모각코24동계] 03 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-1-03plan/</link><pubDate>Wed, 17 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-03plan/</guid><description>오늘의 목표 SQL 서브쿼리 공부</description></item><item><title>[모각코24동계] 02 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-1-02/</link><pubDate>Tue, 09 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-02/</guid><description>SQL 기초 공부 DDL (Data Definition Language) CREATE ALTER DROP RENAME TRUNCATE DML (Data Manipulation Language) SELECT INSERT UPDATE DELETE DCL (Data Control Language) GRANT REVOKE TCL (Transaction Control Language) COMMIT ROLLBACK SAVEPOINT SELECT GROUP BY 특정 Column기준으로 그룹화
그룹화 하지 않은 Column은 집계함수(SUM, COUNT)를 통해서만 조회해야한다
1SELECT name, COUNT(name), SUM(quantity) FROM 테이블 GROUP BY name; HAVING GROUP BY 절에서 조건을 주기 위해 사용</description></item><item><title>[모각코24동계] 02 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-1-02plan/</link><pubDate>Tue, 09 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-02plan/</guid><description>오늘의 목표 SQL 기초 공부 DDL DML DCL TCL DDL (Data Definition Language) DML (Data Manipulation Language) DCL (Data Control Language) TCL (Transaction Control Language)</description></item><item><title>[모각코24동계] 01 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako24-1-01/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-01/</guid><description>1. Agile 방법론 Agile 선언문 사람과 상호작용 &amp;gt; 프로세스와 도구 작동하는 소프트웨어 &amp;gt; 포괄적인 문서 고객과의 협력 &amp;gt; 계약 협상 변화에 대한 대응 &amp;gt; 계획을 따르기 Agile 12가지 원칙 초기부터 지속적으로 고객을 만족 요구사항 변경 수용 짧은 배포 주기 기획자와 개발자의 협업 동기부여된 팀원들로 팀빌딩 얼굴보고 대화하기 동작되는 소프트웨어로 진척 측정 지속 가능한 개발 속도 유지 좋은 기술로 좋은 설계하기 단순성 : 필요없는 일 최소화하기 자기조직화 팀 정기적으로 효율성을 향상시키기 Self-Organizing Team (자기조직화 팀) 스스로 작업을 수행하고 프로세스를 관리하며 진행 상황을 모니터링하는 방법을 스스로 결정하는 팀</description></item><item><title>[모각코24동계] 01 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako24-1-01plan/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-01plan/</guid><description>오늘의 목표 LG CNS 본사 인턴 교육 내용 정리 Agile 방법론 Scrum 방법론</description></item><item><title>[모각코24하계] 00 : 목표</title><link>https://bong-u.github.io/til/mogako/mogako24-1-00/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako24-1-00/</guid><description>나의 목표 성실한 포스팅으로 1일 1커밋을 향해 노력하겠다. 백마인턴십을 수행하면서 업무와 관련한 내용을 공부하며 정리하겠다. 직접 운영 중인 블로그를 개선 시켜 나가겠다.</description></item><item><title>[오픈소스] thefuck - pip uninstall 규칙 추가</title><link>https://bong-u.github.io/til/python/thefuck_pip/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/thefuck_pip/</guid><description>PR #1414 : Correct &amp;ldquo;pip delete|remove&amp;rdquo; -&amp;gt; &amp;ldquo;pip uninstall&amp;rdquo; 배경 pip uninstall &amp;lt;package&amp;gt;는 파이썬 패키지를 삭제하는 명령어이다. 헷갈려서 remove, delete로 오타를 친 경험이 있다. thefuck에서 지원하지 않는 것을 확인하고 기여하기로 했다. 과정 기존의 로직 : 오타가 났을 때, pip 명령에서 “maybe you meant” 하면서 추천해주는 명령어가 있다면 추천, 하지만 remove와 delete는 그 대상이 아님 잘못된 명령어가 ‘delete’ 또는 ‘remove’인 경우 suggest에 uninstall을 대입하도록 수정 1if broken_cmd == &amp;#39;delete&amp;#39; or broken_cmd == &amp;#39;remove&amp;#39;: 2 suggest = &amp;#39;uninstall&amp;#39; 테스트 코드 수정 1# 의도한대로 명령어를 잘 바꿔주는지 테스트 2@pytest.</description></item><item><title>소프트웨어공학</title><link>https://bong-u.github.io/til/school/software_engineering/</link><pubDate>Tue, 24 Oct 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/software_engineering/</guid><description>1장 소프트웨어 공학 개요 소프트웨어의 종류 주문형, 패키지형, 임베디드 시스템 실시간 소프트웨어, 자료처리 소프트웨어 소프트웨어 공학의 정의 IEEE : 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 W.Humphrey : 질 좋은 소프트웨어를 경제적으로 생산하기 위하여 공학, 과학, 수학적 원리에 의하여 소프트웨어를 개발해야한다 소프트웨어 품질 (효-용-신-유-재-) 효율성(efficiency) 사용용이성(usability) 신뢰성(reliability) 유지보수성(maintainability) 재사용성(reusability) 소프트웨어 프로젝트 작업 요구분석과 명세화 도메인 분석, 문제 정의, 요구 추출, 요구 분석, 요구 명세화 설계 : 가용한 기술로 어떻게 구현되어야하는지 기술 시스템 엔지니어링, 소프트웨어 아키텍쳐 UI 설계, DB 설계 모델링 : 도메인이나 소프트웨어의 표현을 만들어 나가는 과정 유스케이스 모델링 정적 모델링, 동적 모델링, 행위 모델링 프로그래밍 품질보증 리뷰, 인스펙션, 테스트 배포 프로세스 관리 2장 소프트웨어 프로세스 폭포수 모델 (Waterfall Model) 각 단계가 다음 시작 전에 끝나야 함 -&amp;gt; 느림 프로토타입과 재사용의 기회가 줄어듦 프로토타입 모델 (Prototyping Model) 인간-기계 상호작용 프로토타입 프로토타입을 만든다 - 프로토타입을 평가한다 점증적 모델 (Incremental Model) 점증적 방법: 기능별로 릴리즈 반복적 방법: 릴리즈 할때마다 기능의 완성도를 높인다 기능이 부족하더라도 빨리 릴리즈 가능 나선형 모델 (Spiral Model) 진화 단계 계획 수립 위험 분석 개발 평가 반복적인 개발 및 테스트 -&amp;gt; 강인성 향상 관리, 위험 분석이 중요 진화적 모델 (Evolutionary Model) 초기에 요구사항을 파악하기 힘들고 구현이 어려운 경우, 요구사항 분석을 한 번이상 반복 UP (Unified Process) 도입 단계 : 프로젝트의 범위를 설정, 목표를 명확히 정련 단계 : 요구를 찾아내어 설계를 완성 구축 단계 : 제조 단계, 요구의 테스트 마무리 전환 단계 : 릴리즈 애자일 프로세스 (Agile Process) 특징 짧은 릴리즈와 반복 점증적 설계 사용자 참여 문서 최소화 비공식적 커뮤니케이션 요구와 환경의 변화를 가정 익스트림 프로그래밍 (eXtreme Pragramming) 애자일 방법론 중 하나 Planning : 요구사항을 작은 요소로 분할 Analysis Design Execution : Coding, Testing Wrapping : small release, process improvement Closure : launch 스크럼 (Scrum) 조직적으로 애자일 방법론을 적용</description></item><item><title>컴퓨터네트워크</title><link>https://bong-u.github.io/til/school/computer_network/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/computer_network/</guid><description>HTTP HTTP Method Method request payload response payload idempotent GET Optional O O HEAD Optional O O POST Yes O X PUT Yes O O DELETE Optional O O CONNECT Optional O X OPTIONS Optional O O TRACE Optional O O PATCH Yes O X HTTP Protocol Version HTTP/1.</description></item><item><title>영화와 문학</title><link>https://bong-u.github.io/til/school/film_and_literature/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/film_and_literature/</guid><description>매체 변환이란 소설, 희곡, 시, 영화 등 각각의 매체 형식을 다른 종류의 매체 형식으로 변환하는 것
뤼미에르 형제에 의해서 영화가 발명된 후, 1910년대부터 기존 문학 작품을 영화의 형식에 맞도록 각색하는 양상이 인기를 얻게 됨.
매체 변환 양상 분석 과정에서 고려해야할 사항
구성의 생략과 압축 텍스트 -&amp;gt; 영화, 시공간적 제약을 받을 수 밖에 없다 따라서, 생략과 압축은 할 수 밖에 없다 시간과 공간의 영상적 변환 시공간을 처리하는 방식은 매체에 따라 달라질 수 밖에 없다.</description></item><item><title>HackerRank - Time Delta</title><link>https://bong-u.github.io/til/algorithm/hrk_time_delta/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/hrk_time_delta/</guid><description>1from datetime import datetime 2 3def time_delta(t1, t2): 4 5 DATE_FORMAT = &amp;#39;%a%d%b %Y %H:%M:%S %z&amp;#39; 6 7 start = datetime.strptime(t1, DATE_FORMAT) 8 end = datetime.strptime(t2, DATE_FORMAT) 9 10 return str(int(abs(start-end).total_seconds())) 문제 정수 T가 주어지고, &amp;ldquo;Sun 10 May 2015 13:54:36 -0700&amp;quot;과 같은 형식의 두 시간이 T개 주어진다 두 시간의 차이를 초 단위로 출력한다 이때, 마지막 +0530, -0700과 같은 숫자는 UTC와의 차이를 나타낸다 TC input 2
Sun 10 May 2015 13:54:36 -0700</description></item><item><title>HackerRank - Merge the Tools</title><link>https://bong-u.github.io/til/algorithm/hrk_merge_the_tools/</link><pubDate>Wed, 04 Oct 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/hrk_merge_the_tools/</guid><description>1def merge_the_tools(string, k): 2 for i in range(0, len(string), k): 3 temp = [] 4 for j in range(i, i+k): 5 if not string[j] in temp: 6 temp.append(string[j]) 7 print (&amp;#39;&amp;#39;.join(temp)) 문제 문자열 S와 정수 k가 주어졌을 때, S를 k 길이의 부분 문자열로 나누고, 각 부분 문자열에서 중복되는 문자를 제거한 뒤 출력한다 TC input s = &amp;lsquo;AABCAAADA&amp;rsquo;, k = 3
ouput AB
CA
AD</description></item><item><title>프로그래머스 - 수식 최대화 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%88%98%EC%8B%9D_%EC%B5%9C%EB%8C%80%ED%99%94/</link><pubDate>Sat, 16 Sep 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%88%98%EC%8B%9D_%EC%B5%9C%EB%8C%80%ED%99%94/</guid><description>1from itertools import permutations 2def solution(expression): 3 answer = 0 4 operations = list(filter(lambda x: not x.isdigit(), expression)) 5 numbers = expression.replace(&amp;#39;-&amp;#39;,&amp;#39;+&amp;#39;).replace(&amp;#39;*&amp;#39;,&amp;#39;+&amp;#39;).split(&amp;#39;+&amp;#39;) 6 expression = [int(numbers[0])] 7 8 for i in range(len(operations)): 9 expression.append(operations[i]) 10 expression.append(int(numbers[i+1])) 11 12 for case in permutations((&amp;#39;+&amp;#39;, &amp;#39;-&amp;#39;, &amp;#39;*&amp;#39;), 3): 13 temp = expression[::-1] 14 for op in case: 15 stack = [] 16 while temp: 17 if temp[-1] == op: 18 temp.pop() 19 a = stack.</description></item><item><title>프로그래머스 - 튜플 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%8A%9C%ED%94%8C/</link><pubDate>Sat, 16 Sep 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%8A%9C%ED%94%8C/</guid><description>1from collections import defaultdict 2 3def solution(s): 4 count = defaultdict(int) 5 for i in s[1:-1].replace(&amp;#39;},{&amp;#39;, &amp;#39;} {&amp;#39;).split(&amp;#39; &amp;#39;): 6 for j in i[1:-1].split(&amp;#39;,&amp;#39;): 7 count[j] += 1 8 return [int(i[0]) for i in sorted(count.items(), key=lambda x: x[1], reverse=True)] 문제 특정 튜플을 포현하는 집합이 담긴 문자열 s가 매개변수로 주어진다 s가 표현하는 튜플을 배열에 담아 반환하라 TC input &amp;ldquo;{{2},{2,1},{2,1,3},{2,1,3,4}}&amp;rdquo;
ouput [2, 1, 3, 4]
해결방법 문제에서 원하는 튜플의 순서는 원소의 개수가 자주 등장하는 순서이다 각 원소의 개수를 세어 count라는 defaultdict에 넣는다 count를 value 기준으로 정렬하여 key값을 list의 형태로 반환하라</description></item><item><title>HackerRank - The Minion Game</title><link>https://bong-u.github.io/til/algorithm/hrk_the_minion_game/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/hrk_the_minion_game/</guid><description>1def minion_game(string): 2 stuart = 0 3 kevin = 0 4 5 for i in range(len(string)): 6 for j in range(i+1, len(string)+1): 7 if string[i] in [&amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;]: 8 kevin += 1 9 else: 10 stuart += 1 11 12 if stuart &amp;gt; kevin: 13 print (&amp;#39;Stuart&amp;#39;, stuart) 14 elif stuart &amp;lt; kevin: 15 print (&amp;#39;Kevin&amp;#39;, kevin) 16 else: 17 print (&amp;#39;Draw&amp;#39;) 문제 Kevin과 Stuart가 The Minion 게임을 한다 게임의 규칙은 다음과 같다 문자열 S가 주어질때, 서로 부분 문자열을 만든다 이때, Kevin은 모음으로, Stuart는 자음으로 시작하는 문자열을 만든다 하나 만들때마다 점수를 +1 얻고 점수가 높은 사람이 이긴다 &amp;ldquo;{게임에서 이긴 사람이름} {이긴 사람의 점수}&amp;ldquo;를 출력하라 동점이면 &amp;ldquo;Draw&amp;quot;를 출력하라 TC input BANANA</description></item><item><title>프로그래머스 - 쿼드압축 후 개수 세기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%BF%BC%EB%93%9C%EC%95%95%EC%B6%95_%ED%9B%84_%EA%B0%9C%EC%88%98_%EC%84%B8%EA%B8%B0/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%BF%BC%EB%93%9C%EC%95%95%EC%B6%95_%ED%9B%84_%EA%B0%9C%EC%88%98_%EC%84%B8%EA%B8%B0/</guid><description>1answer = [0, 0] 2 3def solution(arr): 4 def recursion(sx, sy, k): 5 global answer 6 origin = arr[sy][sx] 7 cnt = 0 8 for i in range(sx, sx+k): 9 for j in range(sy, sy+k): 10 if origin != arr[j][i]: 11 recursion(sx, sy, k//2) 12 recursion(sx+k//2, sy, k//2) 13 recursion(sx, sy+k//2, k//2) 14 recursion(sx+k//2, sy+k//2, k//2) 15 return 16 answer[origin] += 1 17 18 recursion(0, 0, len(arr)) 19 return answer 문제 0과 1로 이루어진 2^n x 2^n 크기의 2차원 정수 배열 arr을 압축하려 한다 압축하는 방법은 당신이 압축하고자 하는 특정 영역을 S라고 정의한다 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킨다 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도한다 TC input [[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]</description></item><item><title>프로그래머스 - 이진 변환 반복하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9D%B4%EC%A7%84_%EB%B3%80%ED%99%98_%EB%B0%98%EB%B3%B5%ED%95%98%EA%B8%B0/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9D%B4%EC%A7%84_%EB%B3%80%ED%99%98_%EB%B0%98%EB%B3%B5%ED%95%98%EA%B8%B0/</guid><description>1def solution(s): 2 answer = [] 3 cnt = 0 4 zero_cnt = 0 5 6 while len(s) != 1: 7 zero = s.count(&amp;#39;0&amp;#39;) 8 s = str(bin(len(s)-zero)).split(&amp;#39;b&amp;#39;)[1] 9 cnt += 1 10 zero_cnt += zero 11 12 return [cnt, zero_cnt] 문제 이진변환을 다음과 같이 정의한다 1. x의 모든 0을 제거한다 2. x의 길이를 c라고 하면, x를 &amp;lsquo;c를 2진법으로 표현한 문자열&amp;rsquo;로 바꾼다 s가 &amp;lsquo;1&amp;rsquo;이 될때까지 이진변환을 가했을 때, [이진변환의 횟수, 제거된 모든 0의 개수]를 반환하라 TC input s : &amp;ldquo;110010101001&amp;rdquo;</description></item><item><title>프로그래머스 - 메뉴 리뉴얼 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A9%94%EB%89%B4_%EB%A6%AC%EB%89%B4%EC%96%BC/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A9%94%EB%89%B4_%EB%A6%AC%EB%89%B4%EC%96%BC/</guid><description>1from itertools import combinations 2from collections import defaultdict 3 4def solution(orders, course): 5 answer = [] 6 7 for i in course: 8 dataset = defaultdict(int) 9 10 for j in orders: 11 for k in combinations(j, i): 12 # ABC, ACB를 같은 것으로 취급하기 위해 정렬 13 dataset[&amp;#39;&amp;#39;.join(sorted(k))] += 1 14 15 if len(dataset) == 0: 16 continue 17 18 max_value = max(dataset.values()) 19 20 # 2번 이상 주문된 메뉴만 추가 21 if max_value == 1: 22 continue 23 24 for k, _ in filter(lambda x:x[1] == max_value, dataset.</description></item><item><title>컴파일러개론</title><link>https://bong-u.github.io/til/school/compiler/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/compiler/</guid><description>개요 컴퓨터와 인간이 소통하는 방법 어셈블리어 어셈블리어의 번역기는 어셈블러(Assembler)라고 한다 cpu칩셋이 바뀔때마다 어셈블리어가 바뀐다 고급언어 고급언어의 번역기는 컴파일러(Compiler)라고 한다 컴파일러의 정확한 정의 어떤 언어로 쓰여진 프로그램을 같은 역할의 다른 언어로 바꿔주는 프로그램
1952년 그레이스 호퍼(Grace Hopper)가 UNIVAC용 프로그래밍언어 A-0 컴파일러를 제작 컴파일러 vs 인터프리터 프로그램 처리과정 컴파일러의 처리 과정 Lexical analysis (어휘 분석) token을 생성하는일, token은 어휘의 최소 단위 Syntax analysis (구문 분석) token을 읽어서 오류를 검색, 구문 구조를 만든다 (주로 트리형태) Semantic analysis (의미 분석) type checking Intermediate code generation (중간 코드 생성) 중간 코드로 변환 Code optimization (코드 최적화) 중간 코드를 더 효율적으로 변환 Code generation (코드 생성) 목적 코드 생성 Lexical analysis (어휘 분석) token : 문법적으로 의미있는 최소 단위 FSA (Finite State Automata, 유한 상태 오토마타) token을 인식하는 방법 시작 상태 한 개와 끝 상태 여러 개를 가짐 DFA (Deterministic Finite Automata) FSA의 한 종류 각 상태에서 뻗어나가는 edge가 하나씩만 존재 ε가 붙은 edge 없음 분석한 토큰을 표현하는 방법 Lexeme = &amp;lt;토큰번호, 토큰 값&amp;gt;</description></item><item><title>프로그래머스 - 순위 검색 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%88%9C%EC%9C%84_%EA%B2%80%EC%83%89/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%88%9C%EC%9C%84_%EA%B2%80%EC%83%89/</guid><description>1from itertools import combinations 2from collections import defaultdict 3from bisect import bisect_left 4 5def solution(infos, queries): 6 answer = [] 7 dataset = defaultdict(list) 8 9 for info in infos: 10 token = info.split(&amp;#39; &amp;#39;) 11 12 for j in range(5): 13 for case in list(combinations([0,1,2,3], j)): 14 temp = token[:-1] 15 for c in case: 16 temp[c] = &amp;#39;-&amp;#39; 17 dataset[&amp;#39;&amp;#39;.join(temp)].append(int(token[-1])) 18 for value in dataset.values(): 19 value.sort() 20 21 for query in queries: 22 query = query.</description></item><item><title>프로그래머스 - 괄호 회전하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%84%ED%98%B8_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%84%ED%98%B8_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</guid><description>1def check(string): 2 stack = [] 3 for i in string: 4 if i == &amp;#39;(&amp;#39; or i == &amp;#39;{&amp;#39; or i == &amp;#39;[&amp;#39;: 5 stack.append(i) 6 else: 7 if len(stack) == 0: 8 return False 9 if i == &amp;#39;)&amp;#39;: 10 if stack[-1] != &amp;#39;(&amp;#39;: return False 11 if i == &amp;#39;}&amp;#39;: 12 if stack[-1] != &amp;#39;{&amp;#39;: return False 13 if i == &amp;#39;]&amp;#39;: 14 if stack[-1] != &amp;#39;[&amp;#39;: return False 15 stack.</description></item><item><title>프로그래머스 - 행렬 테두리 회전하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%96%89%EB%A0%AC_%ED%85%8C%EB%91%90%EB%A6%AC_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%96%89%EB%A0%AC_%ED%85%8C%EB%91%90%EB%A6%AC_%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</guid><description>1dx = [1, 0, -1, 0] 2dy = [0, 1, 0, -1] 3 4def solution(rows, columns, queries): 5 table = [[(j*columns)+i+1 for i in range(columns)] for j in range(rows)] 6 answer = [] 7 8 for y1, x1, y2, x2 in queries: 9 min_num = 10000 10 x1 -= 1 11 y1 -= 1 12 x2 -= 1 13 y2 -= 1 14 direction = 0 15 curX, curY = x1, y1 16 postNum = table[y1][x1] 17 while True: 18 curX = curX+dx[direction] 19 curY = curY+dy[direction] 20 21 temp = table[curY][curX] 22 table[curY][curX] = postNum 23 postNum = temp 24 25 min_num = min(min_num ,postNum) 26 27 if ((curX == x2 and curY == y1) or 28 (curX == x2 and curY == y2) or 29 (curX == x1 and curY == y2)): 30 direction += 1 31 32 if curX == x1 and curY == y1: 33 break 34 35 answer.</description></item><item><title>프로그래머스 - 2개 이하로 다른 비트 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_2%EA%B0%9C_%EC%9D%B4%ED%95%98%EB%A1%9C_%EB%8B%A4%EB%A5%B8_%EB%B9%84%ED%8A%B8/</link><pubDate>Wed, 23 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_2%EA%B0%9C_%EC%9D%B4%ED%95%98%EB%A1%9C_%EB%8B%A4%EB%A5%B8_%EB%B9%84%ED%8A%B8/</guid><description>1def solution(numbers): 2 answer = [] 3 for number in numbers: 4 num = list(str(bin(number)).split(&amp;#39;b&amp;#39;)[1]) 5 6 # 첫번째 자릿수가 0인 경우 7 if num[-1] == &amp;#39;0&amp;#39;: 8 num[-1] = &amp;#39;1&amp;#39; 9 answer.append(int(&amp;#39;0b&amp;#39;+&amp;#39;&amp;#39;.join(num), 2)) 10 continue 11 12 # 첫번째 자릿수가 1인 경우 13 num = [&amp;#39;0&amp;#39;]+num 14 # 두번째 자리부터 순회 15 for i in range(len(num)-2, -1, -1): 16 # 가장 오른쪽의 0을 찾았을 때 17 if num[i] == &amp;#39;0&amp;#39;: 18 # 0을 오른쪽으로, 1을 왼쪽으로 옮긴다 19 num[i], num[i+1] = num[i+1], num[i] 20 answer.</description></item><item><title>프로그래머스 - 거리두기 확인하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0_%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0_%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/</guid><description>1dx = [-1, 1, 0, 0] 2dy = [0, 0, -1, 1] 3def quest(table): 4 table = [list(line) for line in table] 5 for j in range(5): 6 for i in range(5): 7 if table[i][j] == &amp;#39;P&amp;#39;: 8 flag = [False]*4 9 target = [] 10 for k in range(4): 11 nx = i+dx[k] 12 ny = j+dy[k] 13 if 0 &amp;lt;= nx &amp;lt; 5 and 0 &amp;lt;= ny &amp;lt; 5: 14 target.</description></item><item><title>프로그래머스 - 모음사전 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%AA%A8%EC%9D%8C%EC%82%AC%EC%A0%84/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%AA%A8%EC%9D%8C%EC%82%AC%EC%A0%84/</guid><description>1def solution(word): 2 answer = 0 3 char = [&amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;] 4 cnt = 0 5 6 def traverse(cur): 7 nonlocal char, cnt, word 8 if cur == word: 9 return cnt 10 11 if len(cur) &amp;lt; 5: 12 for ch in char: 13 cnt += 1 14 if traverse(cur+ch) != None: 15 return cnt 16 return traverse(&amp;#39;&amp;#39;) 문제 사전에 A,E,I,O,U만 사용하여 만들 수 있는 길이 5이하의 모든 단어가 수록되어있다 단어 하나 word가 주어질때 사전에서 몇번째 단어인지 구하라 TC input &amp;lsquo;I&amp;rsquo;</description></item><item><title>Issue - yaml 문자열 속 colon(콜론)</title><link>https://bong-u.github.io/til/etc/yaml_colon/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/yaml_colon/</guid><description>문제상황 TIL 블로그 자동 배포 github action 코드에 yaml 파일에 내용을 추가하는 부분이 있다
추가하는 문자열에 콜론이 포함되어 있어서 action에서 에러를 띄웠다
문제의 코드
1- name: Add google analytics id 2 run: echo -e &amp;#34;\nparams:\n googleAnalytics : \&amp;#34;$GA_TRACKING_ID\&amp;#34;&amp;#34; &amp;gt;&amp;gt; config.yaml 에러 메시지 해결방법 우여곡절 끝에 위와 같이 2줄로 나누어서 해결했다 1 - name: Add google analytics id 2 run: |3echo -e &amp;#34;\nparams:&amp;#34; &amp;gt;&amp;gt; config.</description></item><item><title>프로그래머스 - 빛의 경로 사이클 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%B9%9B%EC%9D%98_%EA%B2%BD%EB%A1%9C_%EC%82%AC%EC%9D%B4%ED%81%B4/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%B9%9B%EC%9D%98_%EA%B2%BD%EB%A1%9C_%EC%82%AC%EC%9D%B4%ED%81%B4/</guid><description>1dx = [1, 0, -1, 0] 2dy = [0, 1, 0, -1] 3def solution(grid): 4 N = len(grid) 5 M = len(grid[0]) 6 grid = [list(line) for line in grid] 7 route = [[[False]*4 for _ in range(M)] for _ in range(N)] 8 answer = [] 9 10 for i in range(M): 11 for j in range(N): 12 for k in range(4): 13 cur = [i, j] 14 dir = k 15 cnt = 0 16 while not route[cur[1]][cur[0]][dir]: 17 cnt += 1 18 route[cur[1]][cur[0]][dir] = True 19 cur[0] = (cur[0]+dx[dir]) % M 20 cur[1] = (cur[1]+dy[dir]) % N 21 22 if grid[cur[1]][cur[0]] == &amp;#39;L&amp;#39;: 23 dir = (dir-1) % 4 24 elif grid[cur[1]][cur[0]] == &amp;#39;R&amp;#39;: 25 dir = (dir+1) % 4 26 if cnt !</description></item><item><title>프로그래머스 - 전력망을 둘로 나누기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%84%EB%A0%A5%EB%A7%9D%EC%9D%84_%EB%91%98%EB%A1%9C_%EB%82%98%EB%88%84%EA%B8%B0/</link><pubDate>Fri, 18 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%84%EB%A0%A5%EB%A7%9D%EC%9D%84_%EB%91%98%EB%A1%9C_%EB%82%98%EB%88%84%EA%B8%B0/</guid><description>1def solution(n, wires): 2 tower = [[] for _ in range(n)] 3 answer = 100 4 for wire in wires: 5 wire[0] -= 1 6 wire[1] -= 1 7 tower[wire[0]].append(wire[1]) 8 tower[wire[1]].append(wire[0]) 9 10 def traverse(visited, start): 11 visited[start] = True 12 for i in tower[start]: 13 if not visited[i]: 14 traverse(visited, i) 15 for wire in wires: 16 tower[wire[0]].remove(wire[1]) 17 tower[wire[1]].remove(wire[0]) 18 19 visited = [False]*n 20 a = 0 21 traverse(visited, wire[0]) 22 for i in range(n): 23 if visited[i]: 24 a += 1 25 26 visited = [False]*n 27 b = 0 28 traverse(visited, wire[1]) 29 for i in range(n): 30 if visited[i]: 31 b += 1 32 answer = min(answer, abs(a-b)) 33 tower[wire[0]].</description></item><item><title>Issue - MockMvc int타입 param이 null로 들어오는 문제</title><link>https://bong-u.github.io/til/spring/mockmvc_param_null/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/mockmvc_param_null/</guid><description>문제상황 MockMvc를 이용하여 Controller를 테스트하고 있었다
createUser 메소드는 인자로 UserResponse(DTO) 객체를 받는다
UserResponse 내 int타입의 age변수의 값이 null로 들어오는 문제가 있었다
UserController.java
1@PostMapping(&amp;#34;/user&amp;#34;) 2public ResponseEntity&amp;lt;SuccessResponse&amp;lt;UserResponse&amp;gt;&amp;gt; createUser(UserRequest user) { 3 return SuccessResponse.get(201, userService.createUser(user)); 4} UserControllerTest.java
1@Test 2void createUserTest() throws Exception { 3 // Given 4 User user = User.builder() 5 .id(1) 6 .name(&amp;#34;hong&amp;#34;) 7 // age의 값은 분명히 20 8 .age(20) 9 .</description></item><item><title>프로그래머스 - 교점에 별 만들기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B5%90%EC%A0%90%EC%97%90_%EB%B3%84_%EB%A7%8C%EB%93%A4%EA%B8%B0/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B5%90%EC%A0%90%EC%97%90_%EB%B3%84_%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid><description>1def calc(a1, b1, c1, a2, b2, c2): 2 if a1*b2-a2*b1 == 0: 3 return (0.1, 0.1) 4 return ((b1*c2-b2*c1)/(a1*b2-a2*b1), (c1*a2-a1*c2)/(a1*b2-a2*b1)) 5 6def solution(line): 7 answer = [] 8 length = len(line) 9 points = [] 10 size = [1e15, -1e15, 1e15,- 1e15] 11 12 for i in range(length): 13 for j in range(i): 14 point = calc(line[i][0],line[i][1], line[i][2], line[j][0], line[j][1], line[j][2]) 15 if point[0]%1 != 0 or point[1]%1 != 0: 16 continue 17 x = int(point[0]) 18 y = int(point[1]) 19 points.</description></item><item><title>[모각코23하계] 06 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako23-1-06/</link><pubDate>Wed, 16 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-06/</guid><description>프로그래머스 한 문제 풀기 프로그래머스 - n^2 배열 자르기 (L2) 🧠 Algorithm
1def solution(n, left, right): 2 answer = [] 3 start = (left//n, left%n) 4 end = (right//n, right%n) 5 6 for i in range(start[0], end[0]&amp;#43;1): 7 line = [i&amp;#43;1]*(i&amp;#43;1) &amp;#43; [i for i in range(i&amp;#43;2, n&amp;#43;1)] 8 answer &amp;#43;= line 9 10 return answer[start[1]:right-(start[0]*n)&amp;#43;1] 문제 정수 n, left, right가 주어진다 n X n 크기의 2차원 배열을 만든다 i=1,2,3.</description></item><item><title>[모각코23하계] 06 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako23-1-06plan/</link><pubDate>Wed, 16 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-06plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 MockMvc 정리하기</description></item><item><title>프로그래머스 - n^2 배열 자르기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_n2_%EB%B0%B0%EC%97%B4_%EC%9E%90%EB%A5%B4%EA%B8%B0/</link><pubDate>Wed, 16 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_n2_%EB%B0%B0%EC%97%B4_%EC%9E%90%EB%A5%B4%EA%B8%B0/</guid><description>1def solution(n, left, right): 2 answer = [] 3 start = (left//n, left%n) 4 end = (right//n, right%n) 5 6 for i in range(start[0], end[0]+1): 7 line = [i+1]*(i+1) + [i for i in range(i+2, n+1)] 8 answer += line 9 10 return answer[start[1]:right-(start[0]*n)+1] 문제 정수 n, left, right가 주어진다 n X n 크기의 2차원 배열을 만든다 i=1,2,3..n에 대해서, 1행 1열부터 i형 i행까지 숫자 i로 채운다 1행, 2행.. n행을 모두 이어붙인 새로운 1차원 배열을 만든다 새로운 1차원 배열에서 left번째 숫자부터 right번째 숫자까지를 배열로 반환하라 TC input n : 3, left : 2, right : 5</description></item><item><title>프로그래머스 - 피로도 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%94%BC%EB%A1%9C%EB%8F%84/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%94%BC%EB%A1%9C%EB%8F%84/</guid><description>1def solution(k, dungeons): 2 result = 0 3 length = len(dungeons) 4 def dfs(cur, visited, cnt): 5 nonlocal result 6 visit = False 7 for i in range(length): 8 if not visited[i] and cur &amp;gt;= dungeons[i][0]: 9 visit = True 10 visited[i] = True 11 dfs(cur-dungeons[i][1], visited, cnt+1) 12 visited[i] = False 13 14 if not visit: 15 result = max(result, cnt) 16 17 dfs(k, [False]*length, 0) 18 19 return result 문제 유저의 현재 피로도 k, 던전별 [&amp;ldquo;최소 필요 피로도&amp;rdquo;, &amp;ldquo;소모 피로도&amp;rdquo;]를 담은 2차원 배열 dungeons가 주어진다 던전을 탐험하기 위해서는 유저의 현재 남은 피로도가 최소 필요 피로도 이상이어야 한다 던전을 클리어하면 &amp;ldquo;소모 피로도&amp;quot;만큼 피로도가 소모된다 던전을 탐험할 수 있는 최대 던전 수를 구하라 TC input k:80, dungeons:[[80,20],[50,40],[30,10]]</description></item><item><title>React - 로그인 상태와 중첩 라우팅</title><link>https://bong-u.github.io/til/javascript/react_utilize_router/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/react_utilize_router/</guid><description>배경 학부연구생 업무 중에, 로그인 여부에 따라 다른 페이지를 보여주는 기능을 구현해야 했다. 로그인을 하지 않았을때는 &amp;ldquo;/login&amp;quot;으로, 로그인을 했을 때는 &amp;ldquo;/&amp;ldquo;으로 리다이렉트 했다 path가 달라도 공통적으로 적용되는 레이아웃은 중첩 라우팅을 이용하여 구현했다 구조는 다음과 같다 코드 Router.js
1&amp;lt;BrowserRouter&amp;gt; 2 &amp;lt;Routes&amp;gt; 3 &amp;lt;!-- isAuthorized를 prop으로 넘겨서 이미 login한 경우 redirect --&amp;gt; 4 &amp;lt;Route 5 path=&amp;#34;/login&amp;#34; 6 element={&amp;lt;Login isAuthorized={isAuthorized} /&amp;gt;} 7 /&amp;gt; 8 &amp;lt;!-- 로그인을 하지 않았는데 &amp;#34;/&amp;#34;로 접근시 redirect --&amp;gt; 9 {!</description></item><item><title>프로그래머스 - k진수에서 소수 개수 구하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_k%EC%A7%84%EC%88%98%EC%97%90%EC%84%9C_%EC%86%8C%EC%88%98_%EA%B0%9C%EC%88%98_%EA%B5%AC%ED%95%98%EA%B8%B0/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_k%EC%A7%84%EC%88%98%EC%97%90%EC%84%9C_%EC%86%8C%EC%88%98_%EA%B0%9C%EC%88%98_%EA%B5%AC%ED%95%98%EA%B8%B0/</guid><description>1def convert10toN(n, k): 2 result = &amp;#39;&amp;#39; 3 while n &amp;gt; 1: 4 result = str(n%k)+ result 5 n = n // k 6 return (str(n)+result).lstrip(&amp;#39;0&amp;#39;) 7 8def is_prime(n): 9 if n &amp;lt;= 1: 10 return False 11 12 end = int(n**(1/2))+1 13 for i in range(2, end): 14 if n%i == 0: 15 return False 16 return True 17 18 19def solution(n, k): 20 A = convert10toN(n, k) 21 answer = 0 22 for i in A.</description></item><item><title>Spring - JPA : getReferenceById vs findById</title><link>https://bong-u.github.io/til/spring/jpa_getbyid_refbyid/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/jpa_getbyid_refbyid/</guid><description>배경 Service layer에서 createPost 메소드를 구현하는 중 이었다 Post entity는 User entity와 ManyToOne 관계이다 User entity를 가져오는 방식에 따라 두가지 방식의 구현이 가능했다 두 방식의 장단점을 파악해보았다 getReferenceById 사용 1public Post createPost(PostDTO.Request postDTO, int userId) { 2 // 프록시 객체를 가져온다 3 User user = userRepository.getReferenceById(userId); 4 5 Post post = Post.builder() 6 .title(postDTO.getTitle()) 7 .content(postDTO.getContent()) 8 .created_at(LocalDateTime.now().truncatedTo(ChronoUnit.MILLIS)) 9 .author(user) 10 .build(); 11 12 try { 13 return postRepository.</description></item><item><title>프로그래머스 - 주차 요금 계산 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%A3%BC%EC%B0%A8_%EC%9A%94%EA%B8%88_%EA%B3%84%EC%82%B0/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%A3%BC%EC%B0%A8_%EC%9A%94%EA%B8%88_%EA%B3%84%EC%82%B0/</guid><description>1import math 2 3def diff(start, end): 4 sh, sm = map(int, start.split(&amp;#39;:&amp;#39;)) 5 eh, em = map(int, end.split(&amp;#39;:&amp;#39;)) 6 7 return (eh*60+em) - (sh*60+sm) 8 9def calc(time, baseTime, baseFee, unitTime, unitFee): 10 if time &amp;lt; baseTime: 11 return baseFee 12 time -= baseTime 13 return baseFee + math.ceil(time/unitTime)*unitFee 14 15def solution(fees, records): 16 cars = {} 17 for i in records: 18 time, car_num, _ = i.split(&amp;#39; &amp;#39;) 19 # 새로 입차 한 경우 20 if not car_num in cars: 21 cars[car_num] = [0, time] 22 else: 23 # 출차 후 다시 입차한 경우 24 if cars[car_num][1] == &amp;#39;&amp;#39;: 25 cars[car_num][1] = time 26 # 출차한 경우 27 else: 28 cars[car_num][0] += diff(cars[car_num][1], time) 29 cars[car_num][1] = &amp;#39;&amp;#39; 30 31 # 아직 출차하지 않은 차량들에 대해 23:59에 출차한 것으로 간주 32 for num in cars: 33 if cars[num][1] !</description></item><item><title>프로그래머스 - 양궁대회 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%96%91%EA%B6%81%EB%8C%80%ED%9A%8C/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%96%91%EA%B6%81%EB%8C%80%ED%9A%8C/</guid><description>1def solution(n, info): 2 # 각각 몇 번 맞춰야 점수를 얻는지 저장하였다 3 goal_list = [i+1 for i in info] 4 5 cases = [] 6 7 def dfs(score, cnt, case): 8 # 몇 번째 점수인지 나타낸다 (0:10점, 1:9점, ...) 9 length = len(case) 10 if length == 11: 11 # 화살 개수가 남았다면 0점에 채워준다 12 if cnt != n: 13 case[-1] += n-cnt 14 cases.append((score, case)) 15 return 16 # 현재 단계에서 몇 점 맞아야 점수를 따는지를 나타낸다 17 goal = goal_list[length] 18 19 # 점수를 따는 경우 20 if cnt + goal &amp;lt;= n: 21 # 딴 점수를 더해준다 22 dfs(score+(10-length), cnt+goal, case+[goal]) 23 # 상대가 점수를 따는 경우 24 if goal !</description></item><item><title>[모각코23하계] 05 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako23-1-05/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-05/</guid><description>프로그래머스 한 문제 풀기 프로그래머스 - 두 큐 합 같게 만들기 (L2) 🧠 Algorithm
1from collections import deque 2 3def solution(queue1, queue2): 4 sum1, sum2 = sum(queue1), sum(queue2) 5 dq1 = deque(queue1) 6 dq2 = deque(queue2) 7 cnt = 0 8 9 while cnt &amp;amp;lt;= len(queue1)*2&amp;#43;1 and sum1 != sum2: 10 if sum1 &amp;amp;gt; sum2: 11 tmp = dq1.popleft() 12 dq2.append(tmp) 13 sum1 -= tmp 14 sum2 &amp;#43;= tmp 15 elif sum1 &amp;amp;lt; sum2: 16 tmp = dq2.</description></item><item><title>[모각코23하계] 05 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako23-1-05plan/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-05plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 JPA 정리하기</description></item><item><title>프로그래머스 - 두 큐 합 같게 만들기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%ED%81%90_%ED%95%A9_%EA%B0%99%EA%B2%8C_%EB%A7%8C%EB%93%A4%EA%B8%B0/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%ED%81%90_%ED%95%A9_%EA%B0%99%EA%B2%8C_%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid><description>1from collections import deque 2 3def solution(queue1, queue2): 4 sum1, sum2 = sum(queue1), sum(queue2) 5 dq1 = deque(queue1) 6 dq2 = deque(queue2) 7 cnt = 0 8 9 while cnt &amp;lt;= len(queue1)*2+1 and sum1 != sum2: 10 if sum1 &amp;gt; sum2: 11 tmp = dq1.popleft() 12 dq2.append(tmp) 13 sum1 -= tmp 14 sum2 += tmp 15 elif sum1 &amp;lt; sum2: 16 tmp = dq2.popleft() 17 dq1.append(tmp) 18 sum1 += tmp 19 sum2 -= tmp 20 cnt += 1 21 22 return cnt if sum1 == sum2 else -1 문제 길이가 같은 두 큐가 주어진다 두 큐의 합이 같아지도록 큐의 원소를 교환할 수 있는 최소 횟수를 구하라 큐의 pop은 왼쪽에서, push는 오른쪽에서 이루어진다 TC input queue1 : [3, 2, 7, 2], queue2 : [4 ,6, 5, 1]</description></item><item><title>프로그래머스 - 할인 행사 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%95%A0%EC%9D%B8_%ED%96%89%EC%82%AC/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%95%A0%EC%9D%B8_%ED%96%89%EC%82%AC/</guid><description>1from collections import deque 2 3def solution(want, number, discount): 4 want_dict = dict() 5 answer = 0 6 7 for i in range(len(want)): 8 want_dict[want[i]] = number[i] 9 10 for i in discount[:10]: 11 if i in want_dict: 12 want_dict[i] -= 1 13 14 for i in range(0, len(discount)-9): 15 if all(map(lambda x: x &amp;lt;= 0, want_dict.values())): 16 answer += 1 17 18 if discount[i] in want_dict: 19 want_dict[discount[i]] += 1 20 if i+10 &amp;lt; len(discount) and discount[i+10] in want_dict: 21 want_dict[discount[i+10]] -= 1 22 23 return answer 문제 XYZ마트에서는 회원에 가입하면 10일동안 할인혜택을 받는다 할인하는 제품은 하루에 하나씩만 구매할 수 있다 정현이가 원하는 제품 리스트, 원하는 제품의 수량 리스트, 마트에서 할인하는 제품 리스트가 주어진다 정현이가 원하는 제품을 모두 할인 받을 수 있는 회원 등록 날짜의 수를 구하라 TC input want: [&amp;ldquo;banana&amp;rdquo;, &amp;ldquo;apple&amp;rdquo;, &amp;ldquo;rice&amp;rdquo;, &amp;ldquo;pork&amp;rdquo;, &amp;ldquo;pot&amp;rdquo;]</description></item><item><title>Spring - JPA : 프록시 객체, 영속성 전이, 고아 객체</title><link>https://bong-u.github.io/til/spring/jpa2/</link><pubDate>Mon, 07 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/jpa2/</guid><description>프록시 객체 프록시는 JPA의 실제 엔티티를 필요할 때만 꺼내쓰도록하는 가짜 객체이다 em.find 대신 em.getReference를 사용하면 프록시 객체를 얻을 수 있다 JPA에서는 프록시 객체를 사용하여 지연 로딩을 지원한다 FetchType.EAGER (즉시 로딩) 1Order order = em.find(Order.class, orderId); 2Member member = order.getMember(); // 지금 member는 실제 객체이다 3String name = member.getName(); // 1차 캐시에서 조회한다 FetchType.LAZY (지연 로딩) 1Order order = em.find(Order.class, orderId); 2Member member = order.getMember(); // 지금 member는 프록시 객체이다 3String name = member.</description></item><item><title>프로그래머스 - 혼자 놀기의 달인 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90_%EB%86%80%EA%B8%B0%EC%9D%98_%EB%8B%AC%EC%9D%B8/</link><pubDate>Mon, 07 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90_%EB%86%80%EA%B8%B0%EC%9D%98_%EB%8B%AC%EC%9D%B8/</guid><description>1def solution(cards): 2 length = len(cards) 3 visited = [False] * length 4 answer = [] 5 6 for i in range(length): 7 cnt = 0 8 cur = i 9 while not visited[cur-1]: 10 visited[cur-1] = True 11 cur = cards[cur-1] 12 cnt += 1 13 if cnt != 0: 14 answer.append(cnt) 15 16 if len(answer) &amp;lt;= 1: 17 return 0 18 answer.sort(reverse=True) 19 return answer[0]*answer[1] 문제 주어진 배열 cards를 순회한다 cards[i]번째 원소를 방문한다, 이미 방문한 원소인 경우 그만한다 한번 이어서 방문한 원소를 그룹화한다고 할 때, 두 그룹의 원소개수의 곱의 최대값을 구하라 TC input [8,6,3,7,2,5,1,4]</description></item><item><title>JS - Dicom to base64</title><link>https://bong-u.github.io/til/javascript/js_dicom_to_base64/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/js_dicom_to_base64/</guid><description>배경 학부연구생 업무 중에, dicom파일을 서버에 전송하는 작업이 필요했다 보내는 형식은 2가지로 생각했다 dicom파일을 그대로 multipart/form-data 형식으로 보내는 방법 장점 : 파일을 그대로 효율적으로 전송할 수 있다 단점 : 파일 정보를 함께 보내기 어렵다 dicom파일을 base64로 인코딩하여 application/json 형식으로 보내는 방법 장점 : 파일 정보를 함께 보낼 수 있다 단점 : 인코딩으로 인해서 원본 파일보다 용량이 커진다 파일의 정보도 함께 구조화하여 보내기 위해 json형태로 보내는 방식을 택하였다 구현 dicom파일 -&amp;gt; base64 1// Encode a file to BASE64 2 const readFileAsync = (file) =&amp;gt; { 3 return new Promise((resolve, reject) =&amp;gt; { 4 // 비동기적으로 파일을 읽어오기 위해 FileReader 객체를 생성 5 const reader = new FileReader(); 6 7 // 읽기가 끝나면 수행 8 reader.</description></item><item><title>프로그래머스 - 연속 수열 합의 개수 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4_%ED%95%A9%EC%9D%98_%EA%B0%9C%EC%88%98/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4_%ED%95%A9%EC%9D%98_%EA%B0%9C%EC%88%98/</guid><description>첫번째 풀이 1def solution(elements): 2 result = set() 3 length = len(elements) 4 elements = elements*2 5 for i in range(length): 6 temp = 0 7 for j in range(length): 8 temp += elements[i+j] 9 result.add(temp) 10 11 return len(result) 개선한 풀이 1def solution(elements): 2result = set() 3length = len(elements) 4for i in range(length): 5 temp = 0 6 for j in range(length): 7 temp += elements[(i+j)%length] 8 result.</description></item><item><title>Spring - JPA : 개념, 영속성 컨텍스트, 연관 관계 매핑</title><link>https://bong-u.github.io/til/spring/jpa1/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/jpa1/</guid><description>JPA (Java Persistence API) JAVA진영의 ORM 기술 표준, interface 모음 Hibernate, EclipseLink, DataNucleus 등의 구현체가 존재 EntityManager Entity : RDB의 Table과 매핑되는 객체 EntityManagerFactory Entity를 관리하는 EntityManager를 생산하는 공장 Thread safe: O EntityManager Entity의 CRUD등 모든 일을 처리 Thread safe: X 영속성 컨텍스트 Entity를 영구 저장하는 환경 EntityManager는 Entity를 영속성 컨텍스트에 보관하고 관리한다 영속성 컨텍스트에서 관리되는 Entity는 식별자값을 가져야 한다 (ID) -&amp;gt; key-value로 Entity를 관리하기 때문 flush: 영속성 컨텍스트에 변경 내용들을 DB에 동기화하는 작업 영속성 컨텍스트의 이점 1차 캐시 동일성 보장 트랜잭션을 지원하는 쓰기 지연 변경 감지 지연 로딩 Entity의 Life cycle 비영속 (New / Transient): 영속성 컨텍스트와 전혀 관계가 없는 상태 영속 (Managed): 영속성 컨텍스트에 저장된 상태 준영속 (Detached): 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제 (Removed): 삭제된 상태 저장 1EntityManager em = emf.</description></item><item><title>프로그래머스 - 택배상자 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0%EC%83%81%EC%9E%90/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0%EC%83%81%EC%9E%90/</guid><description>1def solution(order): 2 answer = 0 3 length = len(order) 4 stackA = [i for i in range(length, 0, -1)] 5 stackB = [] 6 7 for i in order: 8 while True: 9 if stackA and stackA[-1] == i: 10 stackA.pop() 11 break 12 if stackB and stackB[-1] == i: 13 stackB.pop() 14 break 15 16 if stackB and stackB[-1] &amp;gt; i: 17 return answer 18 19 stackB.append(stackA.pop()) 20 answer += 1 21 22 return answer 문제 원하는 상자 순서를 나타내는 정수배열 order가 주어진다 컨베이어 벨트에 [N&amp;hellip; 3, 2, 1]와 같이 박스가 놓여있다 박스는 1번 상자부터 순차적으로 뺄 수 있다 뺀 상자를 잠깐 보조 컨베이어 벨트에 보관할 수 있다 보조 컨베이어 벨트는 스택과 같이 FILO가 적용된다 순서대로 상자를 싣지 못하면, 그만둔다 박스를 order에 맞게 몇 개까지 실을 수 있는지 구하라 TC input [4, 3, 1, 2, 5]</description></item><item><title>프로그래머스 - 롤케이크 자르기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A1%A4%EC%BC%80%EC%9D%B4%ED%81%AC_%EC%9E%90%EB%A5%B4%EA%B8%B0/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A1%A4%EC%BC%80%EC%9D%B4%ED%81%AC_%EC%9E%90%EB%A5%B4%EA%B8%B0/</guid><description>1def solution(topping): 2 answer = 0 3 length = len(topping) 4 toppingA = [] 5 toppingB = [] 6 setA = set() 7 setB = set() 8 9 for i in range(length-1): 10 setA.add(topping[i]) 11 setB.add(topping[length-i-1]) 12 toppingA.append(len(setA)) 13 toppingB.append(len(setB)) 14 15 toppingB = toppingB[::-1] 16 for i in range(length-1): 17 if toppingA[i] == toppingB[i]: 18 answer+=1 19 return answer 문제 롤케이크 위에 올려진 토핑번호의 정수 배열 topping이 주어진다 롤케이크를 잘랐을 때, 두 조각의 토핑 종류를 똑같이 만드는 방법의 수를 구하라 TC input [1, 2, 1, 3, 1, 4, 1, 2]</description></item><item><title>Spring - Bean Validation : Annotation으로 Validation하기</title><link>https://bong-u.github.io/til/spring/bean_validation/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/bean_validation/</guid><description>Bean Validation Annotation을 달아서 Validation을 수행할 수 있다. 주로 jakarta.validation과 hibernate.validator 두 패키지를 사용한다. Dependency Diagram 구조 spring-boot-starter-validation -&amp;gt; hibernate-validator -&amp;gt; jakarta.validation-api
jakarta.validation에서 지원하는 annotation Annotation Description @NotNull null이 아닌가 (&amp;quot;&amp;quot;, &amp;quot; &amp;quot; =&amp;gt; 통과) @NotEmpty null이 아니고, size가 0인가 (&amp;quot; &amp;quot; =&amp;gt; 통과) @NotBlank null이 아니고, trim한 결과가 empty인가 @Size 문자열, 배열의 길이가 해당 범위에 있는가 @Min 숫자가 해당 범위에 있는가 @Max 숫자가 해당 범위에 있는가 @Email 이메일 형식에 맞는가 @Pattern Regex(정규식)에 맞는가 @Past 과거의 날짜인가 @Future 미래의 날짜인가 @Digits 정수, 소수 자릿수가 해당 범위에 있는가 @DecimalMin, @DecimalMax 자릿수가 해당 범위에 있는가 (소수 이하 자릿수 포함) @Positive, @PositiveOrZero, @Negative, @NegativeOrZero hibernate.</description></item><item><title>프로그래머스 - 우박수열 정적분 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%B0%EB%B0%95%EC%88%98%EC%97%B4_%EC%A0%95%EC%A0%81%EB%B6%84/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%B0%EB%B0%95%EC%88%98%EC%97%B4_%EC%A0%95%EC%A0%81%EB%B6%84/</guid><description>1def solution(k, ranges): 2 answer = [] 3 seq = [k] 4 section = [0] 5 while k &amp;gt; 1: 6 if k%2 == 0: 7 k = k//2 8 else: 9 k = k*3+1 10 seq.append(k) 11 12 for i in range(0, len(seq)-1): 13 a, b = seq[i], seq[i+1] 14 if a &amp;gt; b: 15 a, b = b, a 16 17 section.append((b-a)/2+a) 18 if len(section) != 0: 19 section[-1] += section[-2] 20 21 for i in ranges: 22 a, b = i[0], len(seq)+i[1]-1 23 if a &amp;gt; b: 24 answer.</description></item><item><title>Spring - RESTful API에서 내맘대로 에러 응답하기</title><link>https://bong-u.github.io/til/spring/rest_error_response/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/rest_error_response/</guid><description>1. 클래스 정의 1@Getter 2@RequiredArgsConstructor 3public class ExceptionResponse { 4 private final LocalDateTime timestamp = LocalDateTime.now(); // 2023-08-01T00:00:57.5995502 5 private final int status; // 400 6 private final String error; // MethodArumentNotValidException 7 private final String message; // 이메일 형식이 아닙니다 8 private final String path; // /api/customer 9} 내가 원하는 방식대로 클래스를 정의한다, 주석에는 해당 필드의 예시를 적어놓았다 2. ResponseEntity 만드는 함수 정의 1private ResponseEntity&amp;lt;ExceptionResponse&amp;gt; handleException(HttpStatus status, Exception e, HttpServletRequest request) { 2 ExceptionResponse response = new ExceptionResponse( 3 status.</description></item><item><title>프로그래머스 - 숫자 카드 나누기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EC%B9%B4%EB%93%9C_%EB%82%98%EB%88%84%EA%B8%B0/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EC%B9%B4%EB%93%9C_%EB%82%98%EB%88%84%EA%B8%B0/</guid><description>첫번째 통과한 풀이
1import math 2 3def gcd(a, b): 4 while b &amp;gt; 0: 5 a, b = b, a%b 6 return a 7 8def gcdOfArr(l): 9 result = l[0] 10 for i in range(1, len(l)): 11 result = gcd(result, l[i]) 12 return result 13 14def solution(arrayA, arrayB): 15 a1 = gcdOfArr(arrayA) 16 for i in arrayB: 17 if i % a1 == 0: 18 a1 = 0 19 break 20 a2 = gcdOfArr(arrayB) 21 for i in arrayA: 22 if i % a2 == 0: 23 a2 = 0 24 break 25 return max(a1, a2) 개선한 풀이</description></item><item><title>Method reference (메소드 참조)</title><link>https://bong-u.github.io/til/java/method_reference/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/method_reference/</guid><description>메소드 참조 메소드 참조는 Java 8부터 도입되었다 lambda와 같이 사용하면 간결한 코드를 만들 수 있다 정적 메소드 참조의 문법 1// lambda 식 2(str) -&amp;gt; String.toString(str); 3// 정적 메소드 참조 4String::toString 인스턴스 메소드 참조의 문법 1Person person; 2// lambda 식 3(age) -&amp;gt; person.setAge(); 4// 인스턴스 메소드 참조 5person::setAge 활용 1// lambda식 2getItems.forEach(item -&amp;gt; System.out.println(item)); 3// 메소드 참조 4getItems.forEach(System.out::println);</description></item><item><title>프로그래머스 - 귤 고르기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B7%A4_%EA%B3%A0%EB%A5%B4%EA%B8%B0/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B7%A4_%EA%B3%A0%EB%A5%B4%EA%B8%B0/</guid><description>1def solution(k, tangerine): 2 D = {} 3 for i in tangerine: 4 if i in D: 5 D[i] += 1 6 else: 7 D[i] = 1 8 D = sorted(D.items(), key=lambda x: -x[1]) 9 answer = 0 10 for _, num in D: 11 k -= num 12 answer += 1 13 if k &amp;lt;= 0: 14 break 15 16 return answer 문제 귤의 개수 k와 귤의 개수를 담은 배열 tangerine이 주어진다 귤 k개를 고를 때, 크기가 서로 다른 종류의 수의 최소값을 구하라 TC input k: 6, tangerine: [1, 3, 2, 5, 4, 5, 2, 3]</description></item><item><title>Spring - ResponseEntity 정리</title><link>https://bong-u.github.io/til/spring/responseentity/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/responseentity/</guid><description>ResponseEntity Spring에서 HttpEntity라는 클래스를 지원한다 HttpEntity를 상속받는 두 클래스가 RequestEntity와 ResponseEntity이다 RequestEntity는 http요청을 보낼때 사용하고 ResponseEntity는 http응답을 할때 사용한다 정의 body, header, status를 인자로 넘길 수 있다 1public class ResponseEntity&amp;lt;T&amp;gt; extends HttpEntity&amp;lt;T&amp;gt; { 2 public ResponseEntity(HttpStatusCode status) {...} 3 4 public ResponseEntity(@Nullable T body, HttpStatusCode status) {...} 5 6 public ResponseEntity(MultiValueMap&amp;lt;String, String&amp;gt; headers, HttpStatusCode status) {...} 7 8 public ResponseEntity(@Nullable T body, @Nullable MultiValueMap&amp;lt;String, String&amp;gt; headers, HttpStatusCode status) {.</description></item><item><title>프로그래머스 - 점 찍기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%90_%EC%B0%8D%EA%B8%B0/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%A0%90_%EC%B0%8D%EA%B8%B0/</guid><description>1import math 2 3def solution(k, d): 4 answer = 0 5 6 for x in range(0, d+1, k): 7 a = math.floor((d**2-x**2)**0.5) // k + 1 8 answer += a 9 10 return answer 문제 2차원 좌표 평면에서 (xk (x=0,1,2,3&amp;hellip;), yk (y=0,1,2,3&amp;hellip;)) 지점에 점을 찍는다 원점과의 거리가 d가 넘으면 점을 찍지 않는다 k와 d가 주어질 때, 점이 총 몇 개 찍히는지 구하라 TC input k:2, d:4
ouput 6</description></item><item><title>[모각코23하계] 04 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako23-1-04/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-04/</guid><description>1. 프로그래머스 한 문제 풀기 프로그래머스 - 디펜스 게임 (L2) 🧠 Algorithm
1import heapq 2 3def solution(n, k, enemy): 4 heap = [] 5 cnt = 0 6 for i in enemy: 7 n -= i 8 heapq.heappush(heap, -i) 9 while n &amp;amp;lt; 0: 10 k -= 1 11 if not heap or k &amp;amp;lt; 0: 12 return cnt 13 tmp = -heapq.heappop(heap) 14 n &amp;#43;= tmp 15 cnt &amp;#43;= 1 16 return cnt 문제 n: 가지고 있는 병사 수 k: 사용할 수 있는 무적권 스킬 수 enemy: 라운드마다 존재하는 적 수의 배열 라운드마다 enemy[i]명 만큼 소모하여 enemy[i]마리의 적을 막을 수 있다 무적권을 적절히 사용하여 버틸 수 있는 최대 라운드 수를 구하라 TC input n: 7, k: 3, enemy: [4, 2, 4, 5, 3, 3, 1] 2.</description></item><item><title>[모각코23하계] 04 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako23-1-04plan/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-04plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 @RestController 정리</description></item><item><title>Spring - @RestController 정리</title><link>https://bong-u.github.io/til/spring/restcontroller/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/restcontroller/</guid><description>@RestController @Controller와 @ResponseBody를 합친 Annotation이다 @Controller는 ViewName을 반환해서 DispatcherServlet이 ViewResolver을 사용한다 @RestController는 객체를 반환해서 HttpMessageConverter가 객체를 Json으로 변환한다 @Controller와의 코드 비교 @Controller 1@GetMapping(&amp;#34;&amp;#34;) 2public @ResponseBody List&amp;lt;Voucher&amp;gt; getVouchers() { 3 return voucherRepository.list(); 4} @RestController 1@GetMapping(&amp;#34;&amp;#34;) 2public List&amp;lt;Voucher&amp;gt; getVouchers() { 3 return voucherRepository.list(); 4} @RestControllerAdvice @ControllerAdvice와 같이 @Controller에서 발생한 예외를 전역적으로 처리하는 Annotation이다 @ControllerAdvice와 @RestControllerAdvice의 차이는 @Controller와 @RestController의 차이와 같다 예제 - @RestControllerAdvice 구현 필자는 Controller에서 발생한 IllegalArgumentException을 400 Bad Request로 처리하였다 1@RestControllerAdvice 2public class ControllerExceptionHandler { 3 4 @ExceptionHandler(IllegalArgumentException.</description></item><item><title>프로그래머스 - 디펜스 게임 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%94%94%ED%8E%9C%EC%8A%A4_%EA%B2%8C%EC%9E%84/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%94%94%ED%8E%9C%EC%8A%A4_%EA%B2%8C%EC%9E%84/</guid><description>1import heapq 2 3def solution(n, k, enemy): 4 heap = [] 5 cnt = 0 6 for i in enemy: 7 n -= i 8 heapq.heappush(heap, -i) 9 while n &amp;lt; 0: 10 k -= 1 11 if not heap or k &amp;lt; 0: 12 return cnt 13 tmp = -heapq.heappop(heap) 14 n += tmp 15 cnt += 1 16 return cnt 문제 n: 가지고 있는 병사 수 k: 사용할 수 있는 무적권 스킬 수 enemy: 라운드마다 존재하는 적 수의 배열 라운드마다 enemy[i]명 만큼 소모하여 enemy[i]마리의 적을 막을 수 있다 무적권을 적절히 사용하여 버틸 수 있는 최대 라운드 수를 구하라 TC input n: 7, k: 3, enemy: [4, 2, 4, 5, 3, 3, 1]</description></item><item><title>Spring 개념 - POJO, DAO, DTO, VO, Entity</title><link>https://bong-u.github.io/til/spring/object/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/object/</guid><description>Spring의 여러 객체들 여기저기서 들어봤지만 개념이 머리에 정리되지 않아 기술한다 POJO (Plain Old Java Object) 특정 기술에 종속되지 않는 순수한 자바 객체
기본 생성자를 가진다 아무것도 상속받거나, 구현하지 않아야 한다 getter랑 setter만 존재 해야한다 1public class Person { 2 private String name; 3 private int age; 4 5 public Person() { 6 } 7 8 public String getName() { 9 return name; 10 } 11 12 public int getAge() { 13 return age; 14 } 15 16 public void setName(String name) { 17 this.</description></item><item><title>프로그래머스 - 테이블 해시 함수 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%85%8C%EC%9D%B4%EB%B8%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%85%8C%EC%9D%B4%EB%B8%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98/</guid><description>1def solution(data, col, row_begin, row_end): 2 answer = 0 3 data.sort(key=lambda x: (x[col-1], -x[0])) 4 s = [] 5 for i in range(row_begin-1, row_end): 6 s.append(sum(map(lambda x: x%(i+1), data[i]))) 7 8 for i in s: 9 answer ^= i 10 return answer 문제 해시 함수는 col, row_begin, row_end을 입력으로 받는다 테이블의 튜플을 col번째 컬럼의 값을 기준으로 오름차순 정렬을 하되, 만약 그 값이 동일하면 기본키인 첫 번째 컬럼의 값을 기준으로 내림차순 정렬한다 정렬된 데이터에서 S_i를 i 번째 행의 튜플에 대해 각 컬럼의 값을 i 로 나눈 나머지들의 합으로 정의한다 row_begin ≤ i ≤ row_end 인 모든 S_i를 누적하여 bitwise XOR 한 값을 해시 값으로서 반환하라 TC input data: [[2,2,6],[1,5,10],[4,2,9],[3,8,3]]</description></item><item><title>프로그래머스 - 마법의 엘리베이터 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A7%88%EB%B2%95%EC%9D%98_%EC%97%98%EB%A6%AC%EB%B2%A0%EC%9D%B4%ED%84%B0/</link><pubDate>Mon, 24 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A7%88%EB%B2%95%EC%9D%98_%EC%97%98%EB%A6%AC%EB%B2%A0%EC%9D%B4%ED%84%B0/</guid><description>첫번째 BFS 풀이 1from collections import deque 2 3def solution(storey): 4 answer = 0 5 q = deque() 6 q.append((storey, 0)) 7 visited = [False] * (10**8+1) 8 9 while q: 10 cur, cnt = q.popleft() 11 12 13 visited[cur] = True 14 while cur != 0 and cur%10 == 0: 15 cur = cur // 10 16 if cur == 0: 17 answer = cnt 18 break 19 for j in [-1, 1]: 20 dest = cur + j 21 if 0 &amp;lt;= dest &amp;lt;= 10**8 and not visited[dest]: 22 q.</description></item><item><title>프로그래머스 - 이모티콘 할인행사 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/</link><pubDate>Sun, 23 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98_%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC/</guid><description>1result = [] 2 3def dfs(size, percent, users, emoticons): 4 global result 5 6 if len(percent) == size: 7 temp = [0] * len(users) 8 for i in range(size): 9 for j in range(len(users)): 10 if percent[i]*100 &amp;gt;= users[j][0]: 11 temp[j] += emoticons[i]*(1-percent[i]) 12 serviceNum = 0 13 income = 0 14 for i in range(len(users)): 15 if temp[i] &amp;gt;= users[i][1]: 16 serviceNum += 1 17 else: 18 income += temp[i] 19 result.</description></item><item><title>Spring 개념 - MVC 패턴, Servlet (서블릿)</title><link>https://bong-u.github.io/til/spring/mvc_servlet/</link><pubDate>Fri, 21 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/mvc_servlet/</guid><description>Servlet 개념 클라이언트의 요청을 처리하고, 그 결과를 반환하는 자바 웹 프로그래밍 기술
웹페이지를 동적으로 생성하는 역할을 수행한다 Servlet Conainer의 역할 Servlet의 생명주기를 관리한다 웹서버와의 통신지원 멀티쓰레드 지원, 관리 선언적인 보안 관리 예제 - Servlet 구현 1public class TestServlet extends HttpServlet { 2 private static final Logger logger = LoggerFactory.getLogger(TestServlet.class); 3 4 @Override 5 public void init() throws ServletException {} 6} doGet, doPost 등의 메소드를 구현해서 http 요청을 처리할 수 있다 Servlet Context를 등록하는 방법 web.</description></item><item><title>프로그래머스 - 택배 배달과 수거하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0_%EB%B0%B0%EB%8B%AC%EA%B3%BC_%EC%88%98%EA%B1%B0%ED%95%98%EA%B8%B0/</link><pubDate>Fri, 21 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%83%9D%EB%B0%B0_%EB%B0%B0%EB%8B%AC%EA%B3%BC_%EC%88%98%EA%B1%B0%ED%95%98%EA%B8%B0/</guid><description>1def solution(cap, n, deliveries, pickups): 2 answer = 0 3 tempD = 0 4 tempP = 0 5 for i in range(n-1, -1, -1): 6 tempD += deliveries[i] 7 tempP += pickups[i] 8 9 while tempD &amp;gt; 0 or tempP &amp;gt; 0: 10 tempD -= cap 11 tempP -= cap 12 answer += (i+1)*2 13 return answer 문제 트럭에 실을 수 있는 재활용 택배 상자의 최대개수 cap, 배달할 집의 개수 n 택배 상자의 개수를 담은 deliveries, 재활용 택배 상자의 개수를 담은 pickups가 주어진다 트럭하나로 모든 배달과 수거를 마치고 돌아올 수 있는 최소 이동 거리를 구하라 TC input (cap, n, deliveries, pickups) 4, 5, [1, 0, 3, 1, 2], [0, 3, 0, 4, 0]</description></item><item><title>Spring 개념 - Transaction (트랜잭션)</title><link>https://bong-u.github.io/til/spring/transaction/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/transaction/</guid><description>상황 소비자가 판매자의 물건을 구매하는 함수를 구현 중이라고 하자 물건을 샀을때, 물건의 가격만큼 판매자의 돈은 증가시키고, 소비자의 돈은 감소시켜야한다 판매자의 돈은 증가시켰는데, 소비자의 돈을 감소시키는 중 오류가 났다 오류가 난 경우, 판매자의 돈을 증가시키기 이전으로 Rollback 해야 한다 위의 두가지 연산은 하나의 Transaction으로 묶여서 한번에 처리되어야 한다 Transaction 관리의 종류 Programmatic transaction management (프로그래밍적 트랜잭션 관리)
Transaction 관련 코드를 직접 작성 예제 - TransactionManager 사용 1// Bean 등록 2@Bean 3public PlatformTransactionManager platformTransactionManager(DataSource dataSource) { 4 return new DataSourceTransactionManager(dataSource); 5} 6// 사용할 때 7// 새로운 트랜잭션을 시작한다 8var transaction = transactionManager.</description></item><item><title>프로그래머스 - 시소 짝꿍 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%8B%9C%EC%86%8C_%EC%A7%9D%EA%BF%8D/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%8B%9C%EC%86%8C_%EC%A7%9D%EA%BF%8D/</guid><description>1def solution(weights): 2 answer = 0 3 wdict = {} 4 5 weights.sort(reverse=True) 6 for i in weights: 7 if i in wdict: 8 answer += wdict[i] 9 if i*3/2 in wdict: 10 answer += wdict[i*3/2] 11 if i*2 in wdict: 12 answer += wdict[i*2] 13 if i*4/3 in wdict: 14 answer += wdict[i*4/3] 15 16 wdict[i] = wdict[i]+1 if i in wdict else 1 17 return answer 문제 시소에는 중심으로부터 2m, 3m, 4m 떨어진 거리에 좌석이 존재한다 양쪽의 탑승한 사람의 무게와 시소 축과 좌석 간의 거리의 곱이 같아서 시소가 평행을 이룬다면 그 둘을 시소 짝꿍이라고 할 수 있다 사람들의 몸무게 배열이 주어질 때, 시소 짝꿍이 몇 쌍 존재하는지 구하라 TC input [100,180,360,100,270]</description></item><item><title>[모각코23하계] 03 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako23-1-03/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-03/</guid><description>1. 프로그래머스 한 문제 풀기 프로그래머스 - 숫자 변환하기 (L2) 🧠 Algorithm
1from collections import deque 2 3def solution(x, y, n): 4 q = deque() 5 visited = [False] * 1000001 6 q.append((x, 0)) 7 8 while q: 9 cx, cnt = q.popleft() 10 if cx == y: 11 return cnt 12 13 if cx &amp;#43; n &amp;amp;lt;= y and not visited[cx&amp;#43;n]: 14 q.append((cx&amp;#43;n, cnt&amp;#43;1)) 15 visited[cx&amp;#43;n] = True 16 if cx * 2 &amp;amp;lt;= y and not visited[cx*2]: 17 q.</description></item><item><title>[모각코23하계] 03 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako23-1-03plan/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-03plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 JDBC 정리</description></item><item><title>Java - 이중 중괄호와 Anti-Pattern</title><link>https://bong-u.github.io/til/java/double_brace_initialization/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/double_brace_initialization/</guid><description>기존 코드 1Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); 2map.put(&amp;#34;customerId&amp;#34;, customer.getCustomerId().toString().getBytes()); 3map.put(&amp;#34;name&amp;#34;, customer.getName()); 4map.put(&amp;#34;email&amp;#34;, customer.getEmail()); 5map.put(&amp;#34;createdAt&amp;#34;, Timestamp.valueOf(customer.getCreatedAt())); 6return map; Double Brace Initialization 적용 후 1return new HashMap&amp;lt;&amp;gt;() {{ 2 put(&amp;#34;customerId&amp;#34;, customer.getCustomerId().toString().getBytes()); 3 put(&amp;#34;name&amp;#34;, customer.getName()); 4 put(&amp;#34;email&amp;#34;, customer.getEmail()); 5 put(&amp;#34;createdAt&amp;#34;, Timestamp.valueOf(customer.getCreatedAt())); 6}}; 효과 장점 코드가 가독성이 좋아진다 단점 추가로 익명 클래스를 사용한다 -&amp;gt; 메모리 추가 사용
인스터스 및 개체에 대한 숨겨진 참조를 가진다 -&amp;gt; Memory Leak 유발 가능</description></item><item><title>Spring 개념 - JDBC, DBCP, JdbcTemplate</title><link>https://bong-u.github.io/til/spring/jdbc/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/jdbc/</guid><description>JDBC 자바 프로그램을 DB와 연결해주는 API
JDBC 드라이버 DBMS와 통신을 담당하는 자바 클래스
JDBC 드라이버는 4가지 종류가 있다 (Type 1~4) Mysql은 Type 4를 지원한다 예제 - Connection을 직접 연결 1public List&amp;lt;UUID&amp;gt; findAllIds() { 2 List&amp;lt;UUID&amp;gt; uuids = new ArrayList&amp;lt;&amp;gt;(); 3 try ( 4 var connection = DriverManager.getConnection(url, username, password); 5 var statement = connection.createStatement(); 6 var resultSet = statement.executeQuery(SELECT_ALL_SQL); 7 ) { 8 while (resultSet.next()) { 9 var customerName = resultSet.</description></item><item><title>프로그래머스 - 숫자 변환하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%88%AB%EC%9E%90_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/</guid><description>1from collections import deque 2 3def solution(x, y, n): 4 q = deque() 5 visited = [False] * 1000001 6 q.append((x, 0)) 7 8 while q: 9 cx, cnt = q.popleft() 10 if cx == y: 11 return cnt 12 13 if cx + n &amp;lt;= y and not visited[cx+n]: 14 q.append((cx+n, cnt+1)) 15 visited[cx+n] = True 16 if cx * 2 &amp;lt;= y and not visited[cx*2]: 17 q.append((cx*2, cnt+1)) 18 visited[cx*2] = True 19 if cx * 3 &amp;lt;= y and not visited[cx*3]: 20 q.</description></item><item><title>프로그래머스 - 뒤에 있는 큰 수 찾기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%92%A4%EC%97%90_%EC%9E%88%EB%8A%94_%ED%81%B0_%EC%88%98_%EC%B0%BE%EA%B8%B0/</link><pubDate>Tue, 18 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%92%A4%EC%97%90_%EC%9E%88%EB%8A%94_%ED%81%B0_%EC%88%98_%EC%B0%BE%EA%B8%B0/</guid><description>1def solution(numbers): 2 stack = [] 3 answer = [-1] * len(numbers) 4 5 for i in range(len(numbers)): 6 while stack and stack[-1][1] &amp;lt; numbers[i]: 7 answer[stack[-1][0]] = numbers[i] 8 stack.pop() 9 stack.append((i, numbers[i])) 10 print(stack) 11 12 return answer 문제 정수로 이루어진 배열 numbers가 주어진다 자신 보다 뒤에 있는 숫자 중 가장 크면서 가까운 수를 뒷 큰수라고 한다 모든 원소에 대해서 뒷 큰수를 구하여라 (존재하지 않으면 -1) TC input [2, 3, 3, 5]</description></item><item><title>프로그래머스 - 무인도 여행 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%AC%B4%EC%9D%B8%EB%8F%84_%EC%97%AC%ED%96%89/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%AC%B4%EC%9D%B8%EB%8F%84_%EC%97%AC%ED%96%89/</guid><description>1from collections import deque 2 3vx = [0, 0, -1, 1] 4vy = [-1, 1, 0, 0] 5 6def solution(maps): 7 N = len(maps) 8 M = len(maps[0]) 9 answer = [] 10 11 visited = [[False]*M for _ in range(N)] 12 13 for i in range(N): 14 for j in range(M): 15 if maps[i][j] != &amp;#39;X&amp;#39; and not visited[i][j]: 16 cnt = 0 17 q = deque() 18 q.append((j, i)) 19 visited[i][j] = True 20 while q: 21 cx, cy = q.</description></item><item><title>프로그래머스 - 호텔 대실 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%98%B8%ED%85%94_%EB%8C%80%EC%8B%A4/</link><pubDate>Sun, 16 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%98%B8%ED%85%94_%EB%8C%80%EC%8B%A4/</guid><description>1import heapq 2 3def time_calc(time): 4 time_split = time.split(&amp;#39;:&amp;#39;) 5 return int(time_split[0])*60 + int(time_split[1]) 6 7def solution(book_time): 8 time = [] 9 q = [] 10 for start, end in book_time: 11 time.append((time_calc(start), time_calc(end))) 12 time.sort(key=lambda x: x[0]) 13 print (time) 14 for start, end in time: 15 if q: 16 top = heapq.heappop(q) 17 if top &amp;gt; start: 18 heapq.heappush(q, top) 19 heapq.heappush(q, end+10) 20 else: 21 heapq.heappush(q, end+10) 22 return len(q) 문제 호텔의 예약시간이 담긴 2차원 배열이 주어진다 ex) [[&amp;ldquo;12:00&amp;rdquo;, &amp;ldquo;12:30&amp;rdquo;], [&amp;ldquo;15:00&amp;rdquo;, &amp;ldquo;16:00&amp;rdquo;]] 퇴실 시간 10분 이후에 다음 손님이 입실 할 수 있다 최소 객실의 개수를 구하여라 TC input [[&amp;ldquo;15:00&amp;rdquo;, &amp;ldquo;17:00&amp;rdquo;], [&amp;ldquo;16:40&amp;rdquo;, &amp;ldquo;18:20&amp;rdquo;], [&amp;ldquo;14:20&amp;rdquo;, &amp;ldquo;15:20&amp;rdquo;], [&amp;ldquo;14:10&amp;rdquo;, &amp;ldquo;19:20&amp;rdquo;], [&amp;ldquo;18:20&amp;rdquo;, &amp;ldquo;21:20&amp;rdquo;]]</description></item><item><title>프로그래머스 - 미로 탈출 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%AF%B8%EB%A1%9C_%ED%83%88%EC%B6%9C/</link><pubDate>Fri, 14 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%AF%B8%EB%A1%9C_%ED%83%88%EC%B6%9C/</guid><description>1from collections import deque 2 3vx = [0, 0, -1, 1] 4vy = [-1, 1, 0, 0] 5 6def bfs(maps, N, M, p1, p2): 7 visited = [[False]*M for _ in range(N)] 8 q = deque() 9 q.append(list(p1)+[0]) 10 11 while q: 12 curY, curX, cnt = q.popleft() 13 14 if p2 == (curY, curX): 15 return cnt 16 17 for i in range(4): 18 x = curX + vx[i] 19 y = curY + vy[i] 20 if 0 &amp;lt;= x &amp;lt; M and 0 &amp;lt;= y &amp;lt; N and not visited[y][x] and maps[y][x] !</description></item><item><title>Try with resources로 간결하게 반납하기</title><link>https://bong-u.github.io/til/java/try_with_resources/</link><pubDate>Thu, 13 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/try_with_resources/</guid><description>기존 코드 - try-catch-finally 사용 1Connection connection = null; 2Statement statement = null; 3ResultSet resultSet = null; 4 5try { 6 connection = DriverManager.getConnection(/* SECRET */); 7 statement = connection.createStatement(); 8 9 resultSet = statement.executeQuery(&amp;#34;select * from customers&amp;#34;); 10 11 while (resultSet.next()) { 12 var name = resultSet.getString(&amp;#34;name&amp;#34;); 13 var customerId = UUID.nameUUIDFromBytes(resultSet.getBytes(&amp;#34;customer_id&amp;#34;)); 14 logger.info(&amp;#34;Customer id:{}, name: {}&amp;#34;, customerId, name); 15 } 16} catch (SQLException e) { 17 logger.error(&amp;#34;Error while connecting to DB&amp;#34;, e); 18 throw e; 19} 20finally { 21 try { 22 if (connection !</description></item><item><title>프로그래머스 - 혼자서 하는 틱택토 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90%EC%84%9C_%ED%95%98%EB%8A%94_%ED%8B%B1%ED%83%9D%ED%86%A0/</link><pubDate>Thu, 13 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%ED%98%BC%EC%9E%90%EC%84%9C_%ED%95%98%EB%8A%94_%ED%8B%B1%ED%83%9D%ED%86%A0/</guid><description>1V = [[(-1, 0), (1, 0)], [(0, -1), (0, 1)], [(-1, -1), (1, 1)], [(-1, 1), (1, -1)]] 2P = [[(1, 0), (1, 1), (1, 2)], [(0, 1), (1, 1), (2, 1)], [(1, 1)], [(1, 1)]] 3 4def solution(board): 5 answer = -1 6 o_line = 0 7 x_line = 0 8 9 for i, p_list in enumerate(P): 10 for p in p_list: 11 if board[p[0]][p[1]] != &amp;#39;.&amp;#39; and board[p[0]][p[1]]== board[p[0]+V[i][0][0]][p[1]+V[i][0][1]] == board[p[0]+V[i][1][0]][p[1]+V[i][1][1]]: 12 if board[p[0]][p[1]] == &amp;#39;O&amp;#39;: 13 o_line += 1 14 elif board[p[0]][p[1]] == &amp;#39;X&amp;#39;: 15 x_line += 1 16 17 o_cnt = 0 18 x_cnt = 0 19 20 21 for i in &amp;#39;&amp;#39;.</description></item><item><title>[모각코23하계] 02 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako23-1-02/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-02/</guid><description>1. 프로그래머스 한 문제 풀기 프로그래머스 - 당구 연습 (L2) 🧠 Algorithm
1def solution(m, n, startX, startY, balls): 2 answer = [] 3 for bx, by in balls: 4 tmp = [] 5 for x, y in [(-1*startX, startY), (startX, -1*startY), (startX, 2*n-startY), (2*m-startX, startY)]: 6 if bx==x and (y &amp;amp;lt; 0 &amp;amp;lt; by &amp;amp;lt; startY or startY &amp;amp;lt; by &amp;amp;lt; n &amp;amp;lt; y): 7 continue 8 if by==y and (x &amp;amp;lt; 0 &amp;amp;lt; bx &amp;amp;lt; startX or startX &amp;amp;lt; bx &amp;amp;lt; m &amp;amp;lt; x): 9 continue 10 tmp.</description></item><item><title>[모각코23하계] 02 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako23-1-02plan/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-02plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 Springboot Testing 공부하기</description></item><item><title>프로그래머스 - 당구 연습 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%8B%B9%EA%B5%AC_%EC%97%B0%EC%8A%B5/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%8B%B9%EA%B5%AC_%EC%97%B0%EC%8A%B5/</guid><description>1def solution(m, n, startX, startY, balls): 2 answer = [] 3 for bx, by in balls: 4 tmp = [] 5 for x, y in [(-1*startX, startY), (startX, -1*startY), (startX, 2*n-startY), (2*m-startX, startY)]: 6 if bx==x and (y &amp;lt; 0 &amp;lt; by &amp;lt; startY or startY &amp;lt; by &amp;lt; n &amp;lt; y): 7 continue 8 if by==y and (x &amp;lt; 0 &amp;lt; bx &amp;lt; startX or startX &amp;lt; bx &amp;lt; m &amp;lt; x): 9 continue 10 tmp.</description></item><item><title>Issue - Jar 실행환경에서 ClassPathResource를 가져오지 못하는 문제</title><link>https://bong-u.github.io/til/spring/class_resource_issue/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/class_resource_issue/</guid><description>상황 개발 환경에서는 ClassPathResource를 문제없이 불러온다
jar로 package해서 실행했을 때 오류가 발생한다
Caused by: java.lang.RuntimeException: Cannot read blacklist file at org.academy.springorder.blacklist.BlacklistRepository.list(BlacklistRepository.java:25) at org.academy.springorder.blacklist.BlacklistService.list(BlacklistService.java:16) at org.academy.springorder.CommandLineApplication.main(CommandLineApplication.java:66) ... 8 more 문제의 코드
1 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); 2 3 try { 4 list = Files.readAllLines(blacklist.getFile().toPath()); 5 } 6 catch (IOException e) { 7 throw new RuntimeException(&amp;#34;Cannot read blacklist file&amp;#34;); 8 } 해결 readAllLines를 사용하지 않고 InputStreamReader와 BufferedRearder를 사용하여 해결하였다.</description></item><item><title>프로그래머스 - 리코쳇 로봇 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%A6%AC%EC%BD%94%EC%B3%87_%EB%A1%9C%EB%B4%87/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%A6%AC%EC%BD%94%EC%B3%87_%EB%A1%9C%EB%B4%87/</guid><description>1from collections import deque 2visited = [] 3vx = [0, 0, -1, 1] 4vy = [-1, 1, 0, 0] 5 6def bfs(board, N, M, sp): 7 global visited 8 q = deque() 9 q.append(sp+[1]) 10 11 while q: 12 cy, cx, cnt = q.popleft() 13 visited[cy][cx] = True 14 for i in range(4): 15 x = cx 16 y = cy 17 while True: 18 x += vx[i] 19 y += vy[i] 20 if not (0 &amp;lt;= x &amp;lt; N and 0 &amp;lt;= y &amp;lt; M) or board[y][x] == &amp;#39;D&amp;#39;: 21 x -= vx[i] 22 y -= vy[i] 23 break 24 if board[y][x] == &amp;#39;G&amp;#39;: 25 return cnt 26 if not visited[y][x]: 27 q.</description></item><item><title>Spring 개념 - Profile</title><link>https://bong-u.github.io/til/spring/profile/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/profile/</guid><description>Profile 프로그램을 개발, 테스트, 배포 환경으로 나눠서 실행해야할때가 있다 환경 설정을 위해 spring boot에서는 profile을 사용할 수 있다. 환경 변수 application.yml 1spring.config.activate.on-profile: dev 2env: 3 version: &amp;#34;v1.0.0 dev&amp;#34; 4--- 5spring.config.activate.on-profile: local 6env: 7 version: &amp;#34;v1.0.0 local&amp;#34; 8--- yml 파일에서는 &amp;mdash;를 이용해 파일 분할이 가능하다 spring.config.active.on-profile을 설정해서 특정 프로필에 적용하고 싶은 환경변수를 설정 할 수 있다. application-&amp;lt;profile&amp;gt;.properties .properties파일에서는 여러 파일로 분할하여 설정한다 예를 들어 &amp;ldquo;dev&amp;quot;프로파일에서 적용될 파일은 &amp;ldquo;application-dev.</description></item><item><title>프로그래머스 - 광물 캐기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%91%EB%AC%BC_%EC%BA%90%EA%B8%B0/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B4%91%EB%AC%BC_%EC%BA%90%EA%B8%B0/</guid><description>1def solution(picks, minerals): 2 bundles = [] 3 tmp = [0, 0, 0] 4 DATA = [[1, 1, 1], [5, 1, 1], [25, 5, 1]] 5 answer = 0 6 7 for i in range(len(minerals)): 8 if minerals[i] == &amp;#34;diamond&amp;#34;: 9 for j in range(3): 10 tmp[j] += DATA[j][0] 11 elif minerals[i] == &amp;#34;iron&amp;#34;: 12 for j in range(3): 13 tmp[j] += DATA[j][1] 14 elif minerals[i] == &amp;#34;stone&amp;#34;: 15 for j in range(3): 16 tmp[j] += DATA[j][2] 17 18 if (i+1) % 5 == 0 or i == len(minerals)-1: 19 bundles.</description></item><item><title>Spring 개념 - Environment</title><link>https://bong-u.github.io/til/spring/environment/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/environment/</guid><description>application.properties 환경변수 설정 application.properties 파일을 작성한다 파일 위치 : reousrces/application.properties 파일 내용 예시 : key = value 형태 app.name = spring Configuration에 설정한다 1@Configuration 2@PropertySource(&amp;#34;application.properties&amp;#34;) 3public class AppConfiguration {...} 환경변수 가져오기 ApplicationContext 활용하는 방법 1var environment = applicationContext.getEnvironment(); 2var property = environment.getProperty(&amp;#34;app.name&amp;#34;) @Value Annotation 활용 1@Value(&amp;#34;${app.name}&amp;#34;) 2private String name; 별도의 클래스 정의 클래스 정의
1@Component 2@PropertySource(&amp;#34;version.properties&amp;#34;) 3public class VersionProvider { 4 private final String version; 5 6 public VersionProvider(@Value(&amp;#34;${version:v0.</description></item><item><title>프로그래머스 - 과제 진행하기 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EA%B3%BC%EC%A0%9C_%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EA%B3%BC%EC%A0%9C_%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0/</guid><description>내 답안 1def solution(plans): 2 q = [] 3 answer = [] 4 for plan in plans: 5 h, m = map(int, plan[1].split(&amp;#39;:&amp;#39;)) 6 plan[1] = h*60 + m 7 plan[2] = int(plan[2]) 8 plans.sort(key = lambda x: x[1]) 9 10 for plan in plans: 11 if q: 12 free_time = plan[1] - q[-1][1] 13 while q: 14 q[-1][2] -= free_time 15 free_time = -1 * q[-1][2] 16 17 print (free_time, q[-1][2]) 18 if free_time &amp;lt; 0: 19 break 20 21 if q[-1][2] &amp;lt;= 0: 22 answer.</description></item><item><title>Spring 개념 - IoC (Inversion of Control)</title><link>https://bong-u.github.io/til/spring/ioc/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/ioc/</guid><description>IoC (Inversion of Control) 제어의 역전 메소드나 객체의 호출 작업이, 개발자가 아니라, 외부에서 결정되는 것 객체 간 결합도를 줄이고 유연한 코드를 작성하게 한다 IoC Container IoC가 일어나는 곳, IoC를 수행하는 대상 IoC 클래스 예제 1 public class OrderContext { 2 public OrderRepository orderRepository() { 3 return new OrderRepository(); 4 } 5 6 public OrderService orderService() { 7 return new OrderService(voucherService(), orderRepository()); 8 } 9 } 위 예제에서 OrderContext 클래스가 IoC 컨테이너 역할을 하고 있다 BeanFactory Spring container의 최상위 interface Bean을 생성하고 의존관계를 설정하는 기능을 담당하는 가장 기본적인 IoC 컨테이너 Lazy-loading 방식 사용 : Bean을 사용할때 loading -&amp;gt; 경량 컨테이너 ApplicationContext BeanFactroy의 구현체 Eager-loading 방식 : Runtime에 Bean을 loading &amp;lt;-&amp;gt; Lazy-loading AnnotationConfigApplicationContext ApplicationContext의 구현체 Annotation 기반으로 설정하는 방식 &amp;lt;-&amp;gt; XML방식</description></item><item><title>Spring 개념 - Logging</title><link>https://bong-u.github.io/til/spring/logging/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/logging/</guid><description>Java Logging Framework java.util.logging Apache Commons logging Log4J Logback SLF4J SLF4J (Simple Loggin Facade for Java) Loggin Framework들을 추상화시켜 놓은 것 Facade Pattern을 이용한 Logging framework Log Level trace - debug - info - warn - error
Logger Logger 만들기 1private static final Logger logger = LoggerFactory.getLogger(OrderTester.class); Logger 이름은 보통 FQCN (상위 패키지 + 클래스)으로 사용한다 Logger 사용 1logger.info(&amp;#34;version -&amp;gt; {}&amp;#34;, logger.getName()); logback logback 설정파일 우선순위 logback-test.</description></item><item><title>프로그래머스 - 연속된 부분 수열의 합 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D%EB%90%9C_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4%EC%9D%98_%ED%95%A9/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%97%B0%EC%86%8D%EB%90%9C_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B4%EC%9D%98_%ED%95%A9/</guid><description>1def solution(sequence, k): 2 answer = [] 3 e = len(sequence)-1 4 s = len(sequence) 5 cur = 0 6 7 while s &amp;gt;= 0: 8 if cur &amp;lt; k: 9 s -= 1 10 cur += sequence[s] 11 elif cur &amp;gt; k: 12 cur -= sequence[e] 13 e -= 1 14 else: 15 answer.append((s, e)) 16 s -= 1 17 cur += sequence[s] 18 answer.sort(key=lambda x: (x[1]-x[0], x[0])) 19 return answer[0] 문제 수열과 k가 주어진다 수열의 부분합이 k가 되게 하는 시작인덱스와 끝인덱스를 구하라 이때, 길이가 짧은 수열을 찾는다, 길이가 같은것이 여러가지라면 시작인덱스가 작은 것을 찾는다 TC input [1, 2, 3, 4, 5], 7</description></item><item><title>[모각코23하계] 01 : 결과</title><link>https://bong-u.github.io/til/mogako/mogako23-1-01/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-01/</guid><description>1. 프로그래머스 한 문제 풀기 프로그래머스 - 두 원 사이의 정수 쌍 (L2) 🧠 Algorithm
1import math 2 3def calc1(r): 4 result = 0 5 for i in range(1, r): 6 result &amp;#43;= math.floor(math.sqrt(r**2 - i**2)) 7 return result*4 &amp;#43; r*4 &amp;#43; 1 8 9def calc2(r): 10 result = 0 11 for i in range(1, r): 12 a = math.sqrt(r**2 - i**2) 13 result &amp;#43;= math.floor(a) 14 if a % 1 == 0: 15 result -= 1 16 return result*4 &amp;#43; r*4 &amp;#43; 1 17 18def solution(r1, r2): 19 return calc1(r2)-calc2(r1)&amp;#43;4 문제 두 원의 반지름 r1, r2가 주어진다.</description></item><item><title>[모각코23하계] 01 : 계획</title><link>https://bong-u.github.io/til/mogako/mogako23-1-01plan/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-01plan/</guid><description>오늘의 목표 프로그래머스 한 문제 풀기 Java의 record 개념 정리하기</description></item><item><title>Record</title><link>https://bong-u.github.io/til/java/record/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/record/</guid><description>레코드란 불변(immutable) 데이터 객체를 쉽게 생성할 수 있도록 하는 새로운 유형의 클래스 JDK16부터 지원 예제 Record 적용 전
1public class Person { 2 private final String name; 3 private final int age; 4 5 public Person(String name, int age) { 6 this.name = name; 7 this.age = age; 8 } 9 10 public String getName() { 11 return name; 12 } 13 14 public int getAge() { 15 return age; 16 } 17} Record 적용 후</description></item><item><title>프로그래머스 - 두 원 사이의 정수 쌍 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%EC%9B%90_%EC%82%AC%EC%9D%B4%EC%9D%98_%EC%A0%95%EC%88%98_%EC%8C%8D/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EB%91%90_%EC%9B%90_%EC%82%AC%EC%9D%B4%EC%9D%98_%EC%A0%95%EC%88%98_%EC%8C%8D/</guid><description>1import math 2 3def calc1(r): 4 result = 0 5 for i in range(1, r): 6 result += math.floor(math.sqrt(r**2 - i**2)) 7 return result*4 + r*4 + 1 8 9def calc2(r): 10 result = 0 11 for i in range(1, r): 12 a = math.sqrt(r**2 - i**2) 13 result += math.floor(a) 14 if a % 1 == 0: 15 result -= 1 16 return result*4 + r*4 + 1 17 18def solution(r1, r2): 19 return calc1(r2)-calc2(r1)+4 문제 두 원의 반지름 r1, r2가 주어진다.</description></item><item><title>Spring 개념 - Maven</title><link>https://bong-u.github.io/til/spring/maven/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/maven/</guid><description>Maven coordinates groupId : 회사나 단체명 ex) org.springframework, org.prgms artifactId : 프로젝트 명 ex) spring-context, order-api version : 프로젝트 버전 ex) 5.2.15-RELEASE, 1.0-SNAPSHOT Build lifecycle validate, compile, test, package, verify, install, deploy Trnsitive Dependencies 1A 2├── B 3│ └─ C 4└── D C는 A의 transitive 의존성 Dependency Scope (&amp;lt;scope&amp;gt;) compile(default) : 컴파일, 테스트, 실행에 라이브러리가 필요할때 provided : JDK 또는 컨테이너가 해당 라이브러리를 제공할때 (JSP, servlet) runtime : 실행과 테스트에만 사용될때 (JDBC driver) test : 테스트 컴파일 및 실행에만 필요할때 (easymock, junit) system: provided와 비슷하지만, 사용자가 jar파일의 위치를 지정 example 1&amp;lt;project xmlns=&amp;#34;http://maven.</description></item><item><title>프로그래머스 - 요격 시스템 (L2)</title><link>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%94%EA%B2%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C/</link><pubDate>Tue, 04 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/pgs_%EC%9A%94%EA%B2%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C/</guid><description>1def solution(targets): 2 answer = 0 3 targets.sort(key=lambda x:x[1]) 4 cur = 0 5 6 for i in targets: 7 if i[0] &amp;gt;= cur: 8 answer += 1 9 cur = i[1] 10 11 return answer 문제 개구간 (s, e)의 리스트가 주어진다. 이때, 모든 개구간을 포함하는 최소 숫자의 수를 구하여라 TC input [[4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4]]
ouput 3
해결방법 개구간을 (s, e)에서 e를 정렬하여 해결하였다.</description></item><item><title>Stream, Optional</title><link>https://bong-u.github.io/til/java/stream/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/stream/</guid><description>Lambda 표현식 매개변수 화살표(-&amp;gt;) 함수몸체로 이용하여 사용할 수 있습니다. 함수 몸체가 단일 실행문이면 괄호{}를 생략할 수 있습니다. 함수 몸체가 return문으로만 구성되어 있으면 괄호{}을 생략할 수 있습니다. 1(int x) -&amp;gt; x+1; 2(int x, int y) -&amp;gt; x+y; 3(Thread lamT) -&amp;gt; { lamT.start(); } Stream 특징 원본 데이터를 변경하지 않습니다. 요청되었을때만 데이터를 처리한다. parallelStream()을 이용하여 병렬처리가 가능하다. 예제1 1List&amp;lt;String&amp;gt; highCaloriesFoodName = foodList.stream() 2 .filter(food -&amp;gt; { 3 System.out.println(&amp;#34;filter : &amp;#34; + food.</description></item><item><title>백준 - 11000 : 강의실 배정 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_11000/</link><pubDate>Wed, 28 Jun 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11000/</guid><description>1import heapq 2 3N = int(input()) 4 5L = [] 6for _ in range(N): 7 L.append(tuple(map(int, input().split()))) 8 9L.sort() 10q = [] 11 12heapq.heappush(q, L[0][1]) 13for i in L[1:]: 14 if q[0] &amp;gt; i[0]: 15 heapq.heappush(q, i[1]) 16 else: 17 heapq.heappop(q) 18 heapq.heappush(q, i[1]) 19 20print (len(q)) 문제 강의 개수와 강의 당 시작시간, 종료시간이 주어진다 필요한 강의실 개수를 구하라 (연강 가능)) TC
input 3 1 3 2 4 3 5</description></item><item><title>[모각코23하계] 00 : 목표</title><link>https://bong-u.github.io/til/mogako/mogako23-1-00/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/mogako/mogako23-1-00/</guid><description>나의 목표 1. 성실한 포스팅으로 1일 1커밋을 향해 노력하겠다. 2. SW Academy에서 배운 Spring boot 기술을 상세하게 정리할 것이다. 2. 현재 기술 블로그의 디자인을 개선시킬 것이다. SW Academy 교육과정 - Backend 프레임워크를 위환 Java 심화 실리콘밸리에서 날아온 DataBase Spring Boot Basic 1 Spring Boot Basic 2 Spring Boot Basic 3 Spring Data Security 1 Spring Data Security 2</description></item><item><title>백준 - 2638 : 치즈 (G3)</title><link>https://bong-u.github.io/til/algorithm/boj_2638/</link><pubDate>Mon, 26 Jun 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2638/</guid><description>1from collections import deque 2 3dx = [0, 0, -1, 1] 4dy = [-1, 1, 0, 0] 5 6N, M = map(int, input().split()) 7L = [list(map(int, input().split())) for _ in range(N)] 8 9def check(): 10 q = deque() 11 q.append((0, 0)) 12 13 visited = [[0]*M for _ in range(N)] 14 visited[0][0] = 1 15 16 while q: 17 curX, curY = q.popleft() 18 19 for i in range(4): 20 nX = curX + dx[i] 21 nY = curY + dy[i] 22 23 if 0 &amp;lt;= nX &amp;lt; N and 0 &amp;lt;= nY &amp;lt; M: 24 if L[nX][nY] == 0 and visited[nX][nY] == 0: 25 q.</description></item><item><title>운영체제 - 기말범위</title><link>https://bong-u.github.io/til/school/operatingsystem2/</link><pubDate>Mon, 29 May 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/operatingsystem2/</guid><description>06-File-Management Directory File Directory Directory도 일종의 파일이다 해당 파일 FCB의 식별자만 저장한다 inode (index node) Unix에서는 FCB와 inode가 같다 모든 파일, 폴더가 Unique한 값을 가진다. (root는 2로 고정) File Systems 파티션의 구조 boot block, super block, FCB list, data blocks Partition Control block (Super block) blocks 개수, free data blocks 개수, free data blocks list 저장 inode table, free inode 개수, free inode list 저장 File Control Block (FCB) UNIX에서 128byte의 크기를 가진다 파일 이름, 파일 크기, uid, gid, 파일 주소 등등 저장 Management of Data Blocks Contiguous Allocation 각각의 파일을 연속적으로 저장 Direct Access File grow problem 존재 External fragmentation, Internal fragmentation 발생 Chained Allocation Direct acess File grow problem X External fragmentation X Poor data safety (앞 블록에 문제가 생기면 뒤 블록도 사용 불가능) Indexed Allocation (현대에 사용) Direct access File grow problem X External fragmentation X Medium level data safety (index block만 괜찮으면 된다) Index block이 추가로 필요하다 Free-Space Management Counting N-M&amp;hellip; N번부터 M개의 블록이 비어있다.</description></item><item><title>백준 - 11444 : 피보나치 수 6 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_11444/</link><pubDate>Tue, 09 May 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11444/</guid><description>1def multiply(m1, m2): 2 result = [0, 0, 0, 0] 3 result[0] = (m1[0]*m2[0] + m1[1]*m2[2]) % 1000000007 4 result[1] = (m1[0]*m2[1] + m1[1]*m2[3]) % 1000000007 5 result[2] = (m1[2]*m2[0] + m1[3]*m2[2]) % 1000000007 6 result[3] = (m1[2]*m2[1] + m1[3]*m2[3]) % 1000000007 7 return result 8 9def power(m, n): 10 if (n &amp;gt; 1): 11 m = power (m, n//2) 12 13 m = multiply (m, m) 14 if n % 2 == 1: 15 m = multiply(m, [1,1,1,0]) 16 return m 17 18N = int(input()) 19 20mat = power ([1,1,1,0], N) 21print (mat[1]%1000000007) 문제 n이 주어질 때 n번째 피보나치 수를 구하여라.</description></item><item><title>백준 - 1976 : 여행 가자 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1976/</link><pubDate>Thu, 20 Apr 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1976/</guid><description>1N = int(input()) 2M = int(input()) 3 4parent = [i for i in range(N)] 5 6def find(node): 7 if parent[node] != node: 8 parent[node] = find(parent[node]) 9 return parent[node] 10 11def union(a, b): 12 a = find(a) 13 b = find(b) 14 if a &amp;lt; b: 15 parent[b] = a 16 else: 17 parent[a] = b 18 19for i in range(N): 20 for j, item in enumerate(map(int, input().split())): 21 if item: 22 union(i, j) 23 24path = list(map(int, input().</description></item><item><title>JS - Arguments object 관련 이슈</title><link>https://bong-u.github.io/til/javascript/js_arguments_object_issue/</link><pubDate>Wed, 05 Apr 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/js_arguments_object_issue/</guid><description>상황 나의 기술 블로그와 Google Analytics를 연결하기 위해 tag를 삽입하는 작업 중 이었다. 구글에서 제공하는 태그 소스 중 일부이다. 1function gtag() { 2 dataLayer.push(arguments); 3} 나는 function 키워드를 사용한게 마음에 들지 않아. 아래와 같이 화살표 함수로 바꾸어 작업하였다. 1const gtag = (...args) =&amp;gt; { 2 dataLayer.push(args); 3}; 하지만 내 코드는 정상적으로 동작하지 않았고 구글의 코드 그대로 적용해야만 google analytics가 동작하였다. 이유는 두 방식의 차이점에 있었는데, 어떤 점이 다른건지 알아보게 되었다.</description></item><item><title>Spring Boot Framework - KAKAO 김가연 선배님</title><link>https://bong-u.github.io/til/school/spring_boot/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/spring_boot/</guid><description>REST API REprensentational State Transfer 웹의 장점을 최대한 활용할 수 있는 아키텍처 Layered Architecture Presentation Layer 비즈니스 로직과 UI를 분리 @Controller가 붙은 클래스가 이에 해당 Service Layer 비즈니스 로직 구현 @Service가 붙은 클래스가 이에 해당 Data Access Layer 데이터를 조회, 등록, 수정, 삭제 @Repository가 붙은 클래스가 이에 해당 IoC Inversion of Control : 제어의 역전 모든 객체에 대한 제어권이 바뀌었음을 의미 객체의 주인이 개발자가 아닌 Spring application DI Constructor Injection</description></item><item><title>백준 - 11003 : 최솟값 찾기 (P5)</title><link>https://bong-u.github.io/til/algorithm/boj_11003/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11003/</guid><description>1from collections import deque 2N, L = map(int, input().split()) 3A = list(map(int, input().split())) 4 5Q = deque([(A[0], 0)]) 6result = [A[0]] 7 8for i in range(1, N): 9if Q[0][1] == i-L: 10Q.popleft() 11while Q and Q[-1][0] &amp;gt;= A[i]: 12Q.pop() 13Q.append((A[i], i)) 14result.append(Q[0][0]) 15 16print(*result) 문제 N개의 수 A1, A2, &amp;hellip;, AN 과 L이 주어진다. Di = Ai-L+1 ~ Ai 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. TC input 12 3</description></item><item><title>데이터통신</title><link>https://bong-u.github.io/til/school/data_communication/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/data_communication/</guid><description>메시지(패킷, 프레임), 계층 OSI 7 Model Physical Data Link Network Transport Session Presentation Application TCP/IP 계층 계층 이름 메시지 형태 내용 1 Phisical Bits Bits 2 Data Link Ethernet Frame Ethernet 주소 3 Network IP packet, Datagram IP 주소 4 Transport TCP Segment, UDP Datagram Port 번호 5 Application HTTP 메시지, Email 메시지 URL, Email 주소 Protocol Suite HTTP - TCP - IP - ARP 아날로그 신호 - 사인 함수 $$ y(t) = A sin(2\pi ft + \varphi) $$</description></item><item><title>Git 특강 - 네이버 정다현 선배님</title><link>https://bong-u.github.io/til/school/git/</link><pubDate>Mon, 20 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/git/</guid><description>버전 관리 시스템 중앙집중식 버전 관리(CVCS) Centralized Version Control System
CVCS의 종류 : SVN, Perforce, CVS
문제
중앙 서버의 부하가 큼 오프라인에서는 사용이 불가능 분산 버전 관리 시스템 (DVCS) Decentralized Version Control System DVCS의 종류 : Git, Mercurial, Bazaar Git command gst : git status git log &amp;ndash;oneline : commit을 한줄로 출력 git log &amp;ndash;all &amp;ndash;graph : 그래프로 출력 merge의 3가지 종류 merge : 모든 commit들이 merge commit과 함께 merge squash and merge : 모든 commit들을 하나의 새로운 commit으로 요약하여 merge rebase and merge : 분기가 발생한 기준이 되는 base를 변경 특정 commit으로 롤백하는 방법 reset : commit 이력을 남기지 않고 되돌리기 revert : commit 이력을 남기고 되돌린다 현업에서는 revert를 주로 사용 reset git reset HEAD~ 옵션 &amp;ndash;soft : HEAD 위치 변경, 파일 변화 없음, commit 직전의 상황 &amp;ndash;mixed (default) : add하기 전으로 되돌려 준다, unstaged로 되돌려준다 &amp;ndash;hard : 변경 내용이 모두 사라짐 &amp;ndash;merge : merge 후에 되돌리기 위해서 사용 revert git revert HEAD cherry-pick git cherry pick &amp;lt;commit id&amp;gt; 다른 브랜치의 특정 commit 만을 가져 올 때 사용 Markdown 글자 하이라이트 *글자 기울이기* **굵은 글씨** ~~취소 선~~ 수평선 ---</description></item><item><title>230315 기프랩 Design Thinking 방법론 - 김재정 교수님</title><link>https://bong-u.github.io/til/school/basicprojectlab_design_thinking/</link><pubDate>Wed, 15 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/basicprojectlab_design_thinking/</guid><description>디자인 씽킹이란 공감의 과정을 통해 문제점을 찾아내고, 아이디어를 발산하고, 프로토타입을 만들어 검증 과정을 거치는, 반복적 프로세스에 대한 방법론 및 사고방식 디자인 씽킹 프로세스 공감 - 문제 정의 - 아이디어 도출 - 프로토타이핑 - 테스팅 1. 공감 공감 프로세스 면담하기 관찰하기 경험하기 면담지 준비하기 순차적 경험 질문 : 어떤 순서로 행동하고 경험하는지 물어보자 감정 질문 이유 질문 : 행동 또는 감정에 대한 이유를 물어보자 또 질문 : &amp;ldquo;또&amp;hellip;&amp;ldquo;라는 질문을 많이 하자 구체화 질문 관찰하기 | 모니터링 현장 중심 관찰 : 세상을 넓고 깊게 바라보기 관찰하기 | 쉐도잉 사람의 체험이나 행동을 그자리에서 관찰하기 관찰하기 | 맥락 질의법 현장에서 관찰 및 면담을 통해 대상자에 대한 이해를 하는 방법</description></item><item><title>협업프로세스 - LINE 나도희 선배님</title><link>https://bong-u.github.io/til/school/collaborative_process/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/collaborative_process/</guid><description>IT 업계의 조직 구성 목적 조직 프로젝트 A : 기획, 개발자, 디자이너 프로젝트 B : 기획, 개발자, 디자이너 &amp;hellip; 프로젝트가 커지면 관리가 힘듦
기능 조직 기획 : 기획자, 기획자, 기획자 클라이언트 : 개발자, 개발자, 개발자 서버 : 개발자, 개발자, 개발자 부서내 개발자마다 하는 프로젝트가 다름
개발 방법론 Waterfall 개발 방법론 명확한 요구사항을 가지고 프로젝트를 진행 장점 대략적인 일정 산출이 가능함 프로젝트의 시작과 끝이 명확함 단점 피드백 처리가 느리다 중간에 수정이 어렵다 Agile 개발 방법론 짧은 개발 주기를 가지고 피드백을 계속 반영하면서 진행 단점 프로젝트의 시작과 끝이 명확하지 않다 프로젝트 관리가 상대적으로 어려움이 있음 Kanban : 프로젝트 관리 도구 카드를 이용해서 &amp;ldquo;할일&amp;rdquo;, &amp;ldquo;진행 중&amp;rdquo;, &amp;ldquo;완료&amp;rdquo; 항목을 나누어서 각 테스크의 상태를 관리하는 보드</description></item><item><title>백준 - 17144 : 미세먼지 안녕! (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_17144/</link><pubDate>Wed, 08 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17144/</guid><description>1R, C, T = map(int, input().split()) 2L = [list(map(int, input().split())) for _ in range(R)] 3 4dx = [0, 1, 0, -1] 5dy = [-1, 0, 1, 0] 6dx2 = [0, 1, 0, -1] 7dy2 = [1, 0, -1, 0] 8 9pur_a = (0, 0) 10pur_b = (0, 0) 11 12for i in range(R): 13 if L[i][0] == -1: 14 pur_a = (i, 0) 15 pur_b = (i+1, 0) 16 break 17 18def diffuse(L): 19 L_ = [[0]*C for _ in range(R)] 20 21 for i in range(R): 22 for j in range(C): 23 if L[i][j] &amp;gt; 0: 24 cnt = 0 25 for k in range(4): 26 px = j+dx[k] 27 py = i+dy[k] 28 29 if 0 &amp;lt;= px &amp;lt; C and 0 &amp;lt;= py &amp;lt; R and L[py][px] !</description></item><item><title>백준 - 12851 : 숨바꼭질 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_12851/</link><pubDate>Tue, 07 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_12851/</guid><description>1from collections import deque 2 3position_a, position_b = map(int, input().split()) 4 5q = deque() 6visited = [False]*100001 7result = 0 8cnt = 1 9 10q.append((0, position_a)) 11while q: 12 time, cur = q.popleft(); 13 visited[cur] = True 14 15 if cur == position_b: 16 result = time 17 for i in q: 18 if i == (time, cur): 19 cnt += 1 20 break 21 if cur-1 &amp;gt;= 0 and not visited[cur-1]: 22 q.</description></item><item><title>백준 - 2448 : 별 찍기 - 11 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_2448/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2448/</guid><description>1import math 2 3N = int(input()) 4K = int(math.log2(N//3)) 5arr = [[&amp;#39; &amp;#39;] * (2*N-1) for _ in range(N)] 6 7 8def solve(depth, bx, by): 9 if depth == 0: 10 for i in range(3): 11 for j in range(i*2+1): 12 arr[by+i][bx+(2-i)+j] = &amp;#39;*&amp;#39; 13 arr[by+1][bx+2] = &amp;#39; &amp;#39; 14 else: 15 px = 2**(depth)*3 16 py = 2**(depth-1)*3 17 solve(depth-1, bx+px//2, by) 18 solve(depth-1, bx, by+py) 19 solve(depth-1, bx+px, by+py) 20solve(K, 0, 0) 21for i in arr: 22 print (&amp;#39;&amp;#39;.</description></item><item><title>운영체제 - 중간범위</title><link>https://bong-u.github.io/til/school/operatingsystem1/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/operatingsystem1/</guid><description>운영체제 개요 운영체제의 역할 Program execution Access to computer resources (I/O device, Data&amp;hellip;) Error detection and response Accounting (ex: task manager) 운영체제의 발전 Serial Processing : No OS, No Job scheduling
Simple batch system
OS가 job을 할당 Controlled by monitor Uni-programming
다 실행될때까지 기다림 bad utilization Multiprogramming
The processor can switch to the other job better utilization, needs more memory Time sharing</description></item><item><title>프로그래머로 산다는 것 (리더의 생각) - 쏘카 류석문 CTO님</title><link>https://bong-u.github.io/til/school/socar_cto/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/socar_cto/</guid><description>개발자는 항상 변화하면서 성장해야 한다
개발자의 지속적인 성장 방법 깔끔한 코드 적절한 논리력 (= 문제 해결 능력) 개발이 완료 됐는지 검증하는 방법 ATDD (Acceptance Test Driven Development) : 고객, 개발자, 테스터 간의 커뮤니케이션을 기반으로 하는 개발 방법론 사용하는 코드만 만들기 (Celler Create) 리팩토링 (Refactoring) 코드 읽기 (Code Review) 알고리즘과 데이터 구조 (Don&amp;rsquo;t Reinvent The Wheel) 단순한 디자인 (Simple Design) 진화적 디자인 (Evolutionary Design) 협업 (Cooperative Design Design Review) 기술 벤치마킹 (Benchmarking) 이력서에 git repo 제출할 때, 꾸준히 개선하기 위해 고민하고 관리한 repo를 제출하자</description></item><item><title>백준 - 1043 : 거짓말 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1043/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1043/</guid><description>1N, M = map(int, input().split()) 2T = list(map(int, input().split())) 3T = set(T[1:]) 4 5member = [set() for _ in range(N)] 6party = [] 7visit = [False]*M 8 9def explore(n): 10 for i in member[n]: 11 if not visit[i]: 12 visit[i] = True 13 for j in party[i]: 14 explore(j-1) 15 16for i in range(M): 17 lst = list(map(int, input().split())) 18 lst = lst[1:] 19 for j in lst: 20 member[j-1].add(i) 21 party.</description></item><item><title>백준 - 5639 : 이진 검색 트리 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5639/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5639/</guid><description>풀이방법 1 : 직접 구현 1import sys 2 3sys.setrecursionlimit(10**6) 4class Node: 5 def __init__(self, value): 6 self.value = value 7 self.left = None 8 self.right = None 9 10class BinaryTree: 11 def __init__(self, root): 12 self.root = root 13 14 def insert(self, value): 15 cur_node = self.root 16 while True: 17 if value &amp;lt; cur_node.value: 18 if cur_node.left != None: 19 cur_node = cur_node.left 20 else: 21 cur_node.left = Node(value) 22 break 23 else: 24 if cur_node.</description></item><item><title>자료구조</title><link>https://bong-u.github.io/til/school/data_structure/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/data_structure/</guid><description>제 1장 : 자료구조를 배우기 위한 준비 (230302) 배열 배열(Array): 동일한 타입의 원소들이 연속적인 메모리 공간에 할당되어 있는 기초적인 자료구조 추상데이터 타입 추상데이터타입(ADT:Abstract Data Type) : 데이터와 그 데이터에 대한 추상적인 연산들로써 구성 ADT =~ 자바의 interface, 자료구조 =~ 자바의 class 자료구조는 추상데이터타입을 구체적으로 구현한 것 1-2 수행시간의 분석 알고리즘의 성능: 수행시간을 나타내는 **시간복잡도(Time Complexity)**와 알고리즘이 수행되는 동안 사용되는 메모리 공간의 크기를 나타내는 **공간복잡도(Space Complexity)**에 기반하여 분석 시간 복잡도</description></item><item><title>확률과 통계</title><link>https://bong-u.github.io/til/school/probabilityandstatistics/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/probabilityandstatistics/</guid><description>자료의 정리와 요약 통계 자료의 구분
양적자료(quantitative data) 또는 수치형자료(numerical data) 이산자료(자녀 수), 연속자료(키) 질적자료(qualitative data) 또는 범주형자료(categorical data) 명목자료(혈액형, 성별), 순서자료(학점, 부서평가) 변수의 종류
1all variables 2├── numerical 3│ ├-─ continuous (리터 수) 4│ └-─ discrete (나라 수) 5└─── categorical 6 ├-─ Nominal (성별) 7 └-─ Ordinal (근무 한 시간 : 12-2) 도수분포표 자료의 특성을 기준으로 일정한 계급으로 나누고, 각 계급에 도수를 대응하여 작성한 표</description></item><item><title>쿠버네티스 및 MSA 특강 4일차 : MSA란 무엇인가</title><link>https://bong-u.github.io/til/school/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-4%EC%9D%BC%EC%B0%A8/</link><pubDate>Thu, 23 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-4%EC%9D%BC%EC%B0%A8/</guid><description>MSA란 무엇인가 마이크로서비스 개념 마이크로서비스(microservice)는 애플리케이션을 느슨하게 결합된 서비스의 모임으로 구조화하는 서비스 지향 아키텍처(SOA) 스타일의 일종인 소프트웨어 개발 기법이다 마이크로서비스 아키텍처에서 서비스들은 섬세(fine-grained)하고 프로토콜은 가벼운 편이다. 마이크로서비스 특징 자율성 : 각 구성 요소 서비스는 다른 서비스의 기능에 영향을 주지 않으면서 개발, 배포, 운영하고 확장 가능 전문성 : 각 서비스는 일련의 기능을 위해 설계되며 특정 문제를 해결하는 데 중점을 둔다 마이크로서비스의 기술적 특징 각각의 서비스는 그 크기가 작을 뿐, 서비스 자체는 하나의 모노리식 아키텍처와 유사한 구조를 갖는다 각각의 서비스는 독립적으로 배포가 가능해야 한다 각각의 서비스는 다른 서비스에 대한 의존성이 작아야 한다 각 서비스는 개별 프로세스로 구동되며, REST API와 같은 가벼운 방식으로 통신되어야 한다 마이크로서비스 이점 민첩성 : 소규모 컨텍스트 내에서 활동하며 더 독립적이면서 신속하게 업무를 수행할 수 있다 유연한 확장성 : 서비스가 지원하는 애플리케이션을 기능의 수요를 충족하도록 해당 서비스를 독립적으로 확장할 수 있다 손쉬운 배포 마이크로서비스를 위한 조건 비용 개발 생산성 운영 인프라 배포 주기</description></item><item><title>쿠버네티스 및 MSA 특강 3일차 : 모니터링 시스템 구축 실습 (ELK), kubernetes</title><link>https://bong-u.github.io/til/school/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-3%EC%9D%BC%EC%B0%A8/</link><pubDate>Wed, 22 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-3%EC%9D%BC%EC%B0%A8/</guid><description>모니터링 시스템 구축 실습 (ELK) ELK란 ELK는 Elasticsearch, Logstash 및 Kibana : 오픈 소스 프로젝트 세 개의 머리글
Elasticserach는 검색 및 분석 엔진 Logstash는 여러 소스에서 동시에 데이터를 수집하여 변환한 후 Elasticsearch 같은 &amp;ldquo;stash&amp;quot;로 전송하는 서버 사이드 데이터 처리 파이프라인 Kibana는 사용자가 Elasticsearch에서 차트와 그래프를 이용해 데이터를 시각화 Kibana Elasticsearch에 있는 데이터를 시각화할 수 있도록 하는 웹 브라우저 기반의 시각화 플랫폼
Elasticsearch에 있는 인덱스의 패턴을 찾아서, 데이터를 확인하거나, 시각화할 수 있도록 한다 Logstash 서버 데이터를 수집, 변환, 전송하는 데이터 처리 파이프라인으로, Jruby(JVM 기반 Ruby)로 개발되었다</description></item><item><title>쿠버네티스 및 MSA 특강 2일차 : Docker 실습</title><link>https://bong-u.github.io/til/school/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-2%EC%9D%BC%EC%B0%A8/</link><pubDate>Tue, 21 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-2%EC%9D%BC%EC%B0%A8/</guid><description>Docker 실습 Docker란 무엇인가 Docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼
Docker를 사용하는 이유 개선되고 완벽한 이식성 경량의 중량, 미세한 업데이트 자동화된 컨테이너 작성 컨테이너 버전화 컨테이너 재사용 공유 컨테이너 라이브러리 Docker 오케스트레이션 - Kubernetes Kubernetes는 Google에서 내부용으로 개발된 프로젝트에서 파생된 오픈소스 컨테이너 오케스트레이션 플랫폼 Docker에 자체 오케스트레이션 툴 (Docker Swarm)이 포함되어 있지만, 대부분의 개발자는 그 대신 Kubernetes를 선택한다 Kubernetes는 컨테이너 배치, 업데이트, 서비스감지, 스토리지 프로비저닝, 로드 밸런싱, 상태 모니터링 등을 포함하여 컨테이너 기반 아키텍처의 관리에 필수적인 태스크를 스케줄링하고 자동화한다</description></item><item><title>쿠버네티스 및 MSA 특강 1일차 : 클라우드 컴퓨팅 개념 및 역사</title><link>https://bong-u.github.io/til/school/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-1%EC%9D%BC%EC%B0%A8/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%8F-msa-%ED%8A%B9%EA%B0%95-1%EC%9D%BC%EC%B0%A8/</guid><description>클라우드 제대로 이해하기 클라우드란 개인이 가진 단말기를 통해서는 주로 입/출력 작업만 이루어지고, 정보분석 및 처리, 저장, 관리 유통 등의 작업은 클라우드라고 불리는 제3의 공간에서 이루어지는 컴퓨팅 시스템 형태
클라우드 컴퓨팅이 필요한 이유 비용절감 속도향상 확장성 생산성 클라우드 컴퓨팅 서비스모델 Infrastructure as a Service (IaaS) : IT리소스에 대한 유연성과 관리 제어 기능을 제공 GCE, AWS, Azure Platform as a Service (Paas) : 빌드 및 배포를 위한 환경이 사용자에게 제공 Openshift, Github, docker, kubernetes Software as a a Service (Saas) : 완전한 제품 제공 GShift 비교 On-site &amp;lt; Iaas &amp;lt; Paas &amp;lt; Saas</description></item><item><title>백준 - 14938 : 서강그라운드 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_14938/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_14938/</guid><description>1N, M, R = map(int, input().split()) 2 3item = list(map(int, input().split())) 4G = [[] for _ in range(N)] 5for _ in range(R): 6 a, b, c = map(int, input().split()) 7 G[a-1].append((b-1, c)) 8 G[b-1].append((a-1, c)) 9 10def dfs(node, dist): 11 global result 12 if dist &amp;gt; M: 13 return 14 if not visit[node]: 15 result += item[node] 16 visit[node] = True 17 18 for n_node, n_dist in G[node]: 19 dfs(n_node, dist+n_dist) 20 21max_result = 0 22 23for i in range(N): 24 result = 0 25 visit = [False]*N 26 dfs(i, 0) 27 max_result = max(max_result, result) 28 29print (max_result) 분류에 다익스트라, 플로이드-워셜로 되어있지만 DFS로 풀었다 풀이 방법 여기서는 재방문 했다고 해서 탐색을 하지 않으면 안된다 재방문했을때 전에 방문했을 때보다 더 짧은 통로로 들어왔다면 더 많은 아이템을 얻을 수 있기 때문이다 다만, 아이템은 방문할 때마다 얻을 수 있는 것이 아니기 때문에 주의하여야 한다 위의 내용을 질문게시판을 보다가 깨닫고 풀 수 있었다</description></item><item><title>백준 - 1167 : 트리의 지름 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_1167/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1167/</guid><description>1import sys 2sys.setrecursionlimit(10**6) 3input = sys.stdin.readline 4 5V = int(input()) 6G = [[] for _ in range(V)] 7for _ in range(V): 8 token = list(map(int, input().split()))[:-1] 9 for i in range(1, len(token), 2): 10 G[token[0]-1].append((token[i]-1, token[i+1])) 11 12def dfs(node, dist): 13 global max_node, max_dist 14 visited[node] = True 15 if dist &amp;gt; max_dist: 16 max_node = node 17 max_dist = dist 18 for n_node, n_dist in G[node]: 19 if not visited[n_node]: 20 dfs(n_node, dist+n_dist) 21 22max_node = 0 23 24max_dist = 0 25visited = [False]*V 26dfs(0, 0) 27max_dist = 0 28visited = [False]*V 29dfs(max_node, 0) 30 31print (max_dist) 최근에 푼 &amp;ldquo;1967: 트리의 지름&amp;rdquo; 덕분에 쉽게 해결할 수 있었다 기억하자 트리의 지름 = (어떤 한 정점에서 가장 먼 점 P)에서 가장 먼 점 사이의 거리</description></item><item><title>백준 - 1967 : 트리의 지름(G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1967/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1967/</guid><description>1import sys 2sys.setrecursionlimit(10**6) 3M = int(input()) 4G = [[] for _ in range(M)] 5 6for _ in range(M-1): 7 a, b, c = map(int, input().split()) 8 G[a-1].append((b-1, c)) 9 G[b-1].append((a-1, c)) 10 11n1 = 0 12tmp = 0 13 14def dfs(node, length): 15 global n1, tmp 16 visit[node] = True 17 if length &amp;gt; tmp: 18 tmp = length 19 n1 = node 20 for child, v in G[node]: 21 if not visit[child]: 22 dfs(child, length+v) 23 24visit = [False]*M 25dfs(0, 0) 26tmp = 0 27visit = [False]*M 28dfs(n1, 0) 29print (tmp) 인터넷에서 접근 방법을 참고했다 해결 방법 아무 정점에서 가장 먼 어떤 정점을 N이라고 하자 정점 N에서 가장 먼 정점 사이의 거리가 트리의 지름과 같다 느낀 점 루트를 구할 필요가 없다는 것을 깨달았다</description></item><item><title>백준 - 15681 : 트리와 쿼리 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_15681/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15681/</guid><description>1import sys 2sys.setrecursionlimit(10**6) 3input = sys.stdin.readline 4N, R, Q = map(int, input().split()) 5G = [[] for _ in range(N)] 6cnt = [1]*N 7visited = [False]*N 8 9for _ in range(N-1): 10 a, b = map(int, input().split()) 11 G[a-1].append(b-1) 12 G[b-1].append(a-1) 13 14def dfs(node): 15 visited[node] = True 16 17 for i in G[node]: 18 if not visited[i]: 19 cnt[node] += dfs(i) 20 return cnt[node] 21 22dfs(R-1) 23 24for _ in range(Q): 25 print (cnt[int(input())-1]) 혼자 풀었다!</description></item><item><title>백준 - 2502 : 떡 먹는 호랑이 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_2502/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2502/</guid><description>1D, K = map(int, input().split()) 2L = [(1, 0), (0, 1)] 3 4for i in range(2, D): 5 L.append((L[i-2][0]+L[i-1][0], L[i-2][1]+L[i-1][1])) 6 7A = 1 8B = 2 9 10while True: 11 if A*L[D-1][0] + B*L[D-1][1] == K: 12 break 13 14 if A+1 == B: 15 B += 1 16 A = 1 17 else: 18 A += 1 19 20print (A,&amp;#39;\n&amp;#39;,B, sep=&amp;#39;&amp;#39;) 해결방법 N번째날 떡 개수를 구하기 위해 첫째날 떡, 둘째날 떡을 각각 몇번 더해야하는지 리스트에 구한다 첫째, 둘째 날 떡을 하나하나 넣어보면서 브루트 포스를 수행한다</description></item><item><title>백준 - 13398 : 연속합 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_13398/</link><pubDate>Wed, 08 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_13398/</guid><description>1N = int(input()) 2L = list(map(int, input().split())) 3res = 0 4dp = [[-1000]*N for _ in range(2)] 5dp[0][0] = L[0] 6for i in range(1, N): 7 dp[0][i] = max(dp[0][i-1]+L[i], L[i]) 8 dp[1][i] = max(dp[1][i-1]+L[i], dp[0][i-1]) 9 10print (max(max(dp[0]), max(dp[1]))) 이번 문제에서 사용할 dp 배열의 크기는 N X 2 이다. 배열은 최솟값인 -1000으로 초기화하여야 한다</description></item><item><title>백준 - 15486 : 퇴사 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_15486/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15486/</guid><description>1import sys 2input = sys.stdin.readline 3N = int(input()) 4T = [] 5P = [] 6dp = [0]*(N+1) 7 8for _ in range(N): 9 a, b = map(int, input().split()) 10 T.append(a) 11 P.append(b) 12 13for i in range(N-1, -1, -1): 14 if i+T[i] &amp;gt; N: 15 dp[i] = dp[i+1] 16 else: 17 dp[i] = max(P[i]+dp[i+T[i]], dp[i+1]) 18 19print (dp[0]) dp라는 변수를 만들어야하는데 안 만들고 리스트 P만 가지고 memoization 하려다 실패했다 점화식은 잘 적었으나 조건문이 잘 못되어서 다른 풀이를 참고했다</description></item><item><title>MVC 3 : Session, Interceptor, Cookies</title><link>https://bong-u.github.io/til/spring/13_mvc_3/</link><pubDate>Mon, 06 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/13_mvc_3/</guid><description>Session 로그인 할 때 세션에 등록 LoginController.java 1@PostMapping 2public String submit(LoginCommand loginCommand, Errors errors, HttpSession session) { 3new LoginCommandValidator().validate(loginCommand, errors); 4if (errors.hasErrors()) { 5 return &amp;#34;login/loginForm&amp;#34;; 6} 7 8try { 9 AuthInfo authInfo = authService.authenticate(loginCommand.getEmail(), loginCommand.getPassword()); 10 11 session.setAttribute(&amp;#34;authInfo&amp;#34;, authInfo); 12 return &amp;#34;login/loginSuccess&amp;#34;; 13} 14catch (WrongIdPasswordException e) { 15 errors.reject(&amp;#34;idPasswordNotMatching&amp;#34;); 16 return &amp;#34;login/loginForm&amp;#34;; 17} 18} 로그아웃 할때 세션에서 삭제 LogoutController.java 1@RequestMapping(&amp;#34;/logout&amp;#34;) 2public String logout(HttpSession session) { 3 session.</description></item><item><title>백준 - 2631 : 줄세우기 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_2631/</link><pubDate>Sat, 04 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2631/</guid><description>1N = int(input()) 2L = [] 3for i in range(N): 4 L.append(int(input())) 5 6dp = [1]*N 7 8for i in range(N): 9 for j in range(i): 10 if L[j] &amp;lt; L[i]: 11 dp[i] = max(dp[i], dp[j]+1) 12 13print (N-max(dp)) LIS를 활용한 문제이다 풀이 유도는 잘했으나 LIS가 헷갈려서 전에 풀었던 코드를 참고하였다</description></item><item><title>백준 - 1915 : 가장 큰 정사각형 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_1915/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1915/</guid><description>1N, M = map(int, input().split()) 2 3L = [list(map(int, input())) for _ in range(N)] 4 5dp = [[0]*(M+1) for _ in range(N+1)] 6 7result = 0 8 9for i in range(1, N+1): 10 for j in range(1, M+1): 11 dp[i][j] = L[i-1][j-1] 12 13 if L[i-1][j-1]: 14 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 15 result = max(result, dp[i][j]) 16 17for i in dp: 18 print (i) 19print (result**2) 조금 시간이 걸렸지만 혼자 힘으로 풀었다 점화식은 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1이다.</description></item><item><title>백준 - 1918 : 후위 표기식 (G2)</title><link>https://bong-u.github.io/til/algorithm/boj_1918/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1918/</guid><description>1string = list(input()) 2 3priority = {&amp;#39;(&amp;#39;:0, &amp;#39;)&amp;#39;:0, &amp;#39;+&amp;#39;:1, &amp;#39;-&amp;#39;:1, &amp;#39;*&amp;#39;:2, &amp;#39;/&amp;#39;:2} 4operator = [] 5result = &amp;#39;&amp;#39; 6 7for c in string: 8 if c.isalpha(): 9 result += c 10 elif c == &amp;#39;(&amp;#39;: 11 operator.append(c) 12 elif c == &amp;#39;)&amp;#39;: 13 while operator: 14 op = operator.pop() 15 if op == &amp;#39;(&amp;#39;: 16 break 17 result += op 18 else: 19 if operator: 20 if priority[operator[-1]] &amp;lt; priority[c]: 21 operator.</description></item><item><title>백준 - 9252 : LCS 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_9252/</link><pubDate>Thu, 02 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_9252/</guid><description>1S1 = list(input()) 2S2 = list(input()) 3 4N1 = len(S1)+1 5N2 = len(S2)+1 6 7dp = [[0]*(N1) for _ in range(N2)] 8 9for i in range(1, N2): 10 for j in range(1, N1): 11 if S2[i-1] == S1[j-1]: 12 dp[i][j] = dp[i-1][j-1] + 1 13 else: 14 dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 15i = N2-1 16j = N1-1 17print (dp[i][j]) 18if dp[i][j] == 0: 19 exit() 20 21result = &amp;#39;&amp;#39; 22while True: 23 if i==0 or j==0: 24 break 25 26 if dp[i][j] == dp[i-1][j]: 27 i -= 1 28 elif dp[i][j] == dp[i][j-1]: 29 j -= 1 30 else: 31 result = S1[j-1] + result 32 i -= 1 33 j -= 1 34 35print (result) 점화식을 잘못 세웠었다 문자가 같은 경우에 max(dp[i-1][j], dp[i][j-1])+1이 아닌 dp[i-1][j-1]+1이다.</description></item><item><title>Generics</title><link>https://bong-u.github.io/til/java/generics/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/generics/</guid><description>효과 : 타입안정성, 간결한 코드 Generic class 1public class Box&amp;lt;M, I&amp;gt; { 2 private M material; 3 private I item; 4 ... 5} 6 7Box&amp;lt;Paper, String&amp;gt; box = new Box&amp;lt;Paper, String&amp;gt;(); Generic Function 1public class CoffeeMachine { 2 public &amp;lt;T&amp;gt; Coffee makeCoffee(T capsule) { 3 return new Coffee(capsule); 4 } 5} 6CoffeeMachine coffeeMachine = new CoffeeMachine(); 7Colombian capsule = new Colombian(); 8coffeeMachine.&amp;lt;Colombian&amp;gt;makeCoffee(capsule); 9coffeeMachine.makeCoffee(capsule); Restrictions on Generics 1// BoxMaterial을 상속 받았으면서 Hard(인터페이스)를 구현한 클래스만 가능 2public class Box&amp;lt;M extends BoxMaterial &amp;amp; Hard&amp;gt; 3// BoxMaterial의 조상 클래스만 가능 4public class Box&amp;lt;T super BoxMaterial&amp;gt; Whild Card 1// T와 그 자손만 가능 2&amp;lt;?</description></item><item><title>MVC 2 : Messages, Validate command object</title><link>https://bong-u.github.io/til/spring/12_mvc_2/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/12_mvc_2/</guid><description>Messages label.properties member.register=회원가입 1&amp;lt;%@ taglib prefix=&amp;#34;spring&amp;#34; uri=&amp;#34;http://www.springframework.org/tags&amp;#34; %&amp;gt; 2&amp;lt;head&amp;gt; 3 &amp;lt;title&amp;gt;&amp;lt;spring:message code=&amp;#34;member.register&amp;#34; /&amp;gt;&amp;lt;/title&amp;gt; 4&amp;lt;/head&amp;gt; 사이트가 여러 언어를 지원해야할 때 label_ko.properties, label_en.properties와 같이 만든다고 한다 http헤더의 Accept-Launguage를 자동으로 인식한다고 하니까 편할 것 같다 Validate command object Validation RegisterRequestValidator 1@Override 2public void validate(Object target, Errors errors) { 3 RegisterRequest regReq = (RegisterRequest) target; 4 5 if(regReq.getEmail() == null | regReq.getEmail().trim().isEmpty()) { 6 errors.rejectValue(&amp;#34;email&amp;#34;, &amp;#34;bad&amp;#34;); 7 } 8 else { 9 Matcher matcher = pattern.</description></item><item><title>백준 - 10942 : 팰린드롬? (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_10942/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10942/</guid><description>1import sys 2input = sys.stdin.readline 3 4N = int(input()) 5L = list(map(int, input().split())) 6 7dp = [[0]*N for _ in range(N)] 8 9for i in range(N): 10 dp[i][i] = 1 11 if i &amp;lt; N-1 and L[i] == L[i+1]: 12 dp[i][i+1] = 1 13 14for i in range(N, -1, -1): 15 for j in range(i+1, N): 16 if dp[i+1][j-1] and L[i] == L[j]: 17 dp[i][j] = 1 18 19for i in range(int(input())): 20 S, E = map(int, input().</description></item><item><title>백준 - 5582 : 공통 부분 문자열 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5582/</link><pubDate>Tue, 31 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5582/</guid><description>1S1 = list(input()) 2S2 = list(input()) 3L1 = len(S1)+1 4L2 = len(S2)+1 5 6dp = [[0]*L1 for _ in range(L2)] 7result = 0 8 9for i in range(1, L2): 10 for j in range(1, L1): 11 if S1[j-1] == S2[i-1]: 12 dp[i][j] = dp[i-1][j-1]+1 13 result = max(result, dp[i][j]) 14 15print (result) 혼자 힘으로 해결! 깔끔한 풀이가 나와 기분이 좋다</description></item><item><title>백준 - 5557 : 1학년 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_5557/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_5557/</guid><description>1N = int(input()) 2L = list(map(int, input().split())) 3dp = [[0]*21 for _ in range(N-1)] 4 5dp[0][L[0]] = 1 6 7for i in range(0, N-2): 8 for j in range(21): 9 if dp[i][j] != 0: 10 k = L[i+1] 11 if k != 0: 12 if 0 &amp;lt;= j+k &amp;lt;= 20: 13 dp[i+1][j+k] += dp[i][j] 14 if 0 &amp;lt;= j-k &amp;lt;= 20: 15 dp[i+1][j-k] += dp[i][j] 16 else: 17 dp[i+1][j] = dp[i][j]*2 18print (dp[N-2][L[-1]]) 혼자 힘으로 풀었다!</description></item><item><title>백준 - 10164 : 격자상의 경로 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_10164/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10164/</guid><description>1N, M, K = map(int, input().split()) 2K -= 1 3ox = K % M 4oy = K // M 5def solve(sx, sy, ex, ey): 6 dp = [[0]*M for _ in range(N)] 7 dp[sy][sx] = 1 8 for i in range(sy, ey+1): 9 for j in range(sx, ex+1): 10 if i-1 &amp;gt;= 0: 11 dp[i][j] += dp[i-1][j] 12 if j-1 &amp;gt;= 0: 13 dp[i][j] += dp[i][j-1] 14 return dp[ey][ex] 15 16if K !</description></item><item><title>백준 - 2011 : 암호코드 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2011/</link><pubDate>Sat, 28 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2011/</guid><description>1L = list(input()) 2N = len(L) 3MOD = 10**6 4 5def solution(): 6 if L[0] == &amp;#39;0&amp;#39;: 7 return 0 8 9 dp = [1, 1]+[0]*(N-1) 10 11 for i in range(2, N+1): 12 if L[i-1] != &amp;#39;0&amp;#39;: 13 dp[i] = (dp[i]+dp[i-1]) % MOD 14 if 10 &amp;lt;= int(L[i-2]+L[i-1]) &amp;lt;= 26: 15 dp[i] = (dp[i]+dp[i-2]) % MOD 16 17 return dp[N] 18 19 20print (solution()) 인터넷을 참고하여 풀었다</description></item><item><title>백준 - 1495 : 기타리스트 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1495/</link><pubDate>Fri, 27 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1495/</guid><description>1N, S, M = map(int, input().split()) 2P = list(map(int, input().split())) 3dp = [[False]*(M+1) for _ in range(N+1)] 4 5dp[0][S] = True 6 7for i in range(1, N+1): 8 for j in range(M+1): 9 if dp[i-1][j]: 10 if 0 &amp;lt;= j-P[i-1] &amp;lt;= M: 11 dp[i][j-P[i-1]] = True 12 if 0 &amp;lt;= j+P[i-1] &amp;lt;= M: 13 dp[i][j+P[i-1]] = True 14result = -1 15for i in range(M+1): 16 if dp[N][i]: 17 result = i 18print (result) 인터넷에서 접근을 참고했다</description></item><item><title>백준 - 16194 : 카드 구매하기 2 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_16194/</link><pubDate>Thu, 26 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_16194/</guid><description>1N = int(input()) 2P = list(map(int, input().split())) 3dp = [10000000]*(N) 4 5for i in range(N): 6 for j in range(i): 7 dp[i] = min(dp[i], dp[j]+P[i-j-1]) 8 dp[i] = min(dp[i], P[i]) 9 10print (dp[N-1])</description></item><item><title>백준 - 1965 : 상자넣기 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_1965/</link><pubDate>Wed, 25 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1965/</guid><description>1N = int(input()) 2L = list(map(int, input().split())) 3dp = [0]*N 4 5for i in range(1, N): 6 for j in range(i): 7 if L[j]&amp;lt;L[i] and dp[i]&amp;lt;dp[j]+1: 8 dp[i] = dp[j]+1 9print(max(dp)+1) LIS를 구하는 문제이다</description></item><item><title>React - build 이후 빈 화면만 나오는 문제</title><link>https://bong-u.github.io/til/javascript/react_deploy_issue/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/react_deploy_issue/</guid><description>build 결과물을 돌리면 빈 화면만 나오는 문제 static files 로딩에 성공했는지 확인하자 문제가 있다면 index.html의 경로를 수정하자 react-router를 사용하고 있다면 url을 확인하자 deploy할때 root url이 아니라면 router에 basename을 추가해줘야한다. 1&amp;lt;Router basename=&amp;#34;/index&amp;#34;&amp;gt;...&amp;lt;/Router&amp;gt;</description></item><item><title>React - environment variable 설정하기</title><link>https://bong-u.github.io/til/javascript/react_env_var/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/react_env_var/</guid><description> 프로그램이 개발/배포 상황에 따라 변수를 달리해야 할 때가 있다. 이때 react에서는 .env.development , .env.production 파일을 만들어서 환경변수를 쉽게 관리할 수 있다. react는 앞에 &amp;lsquo;REACT_APP&amp;rsquo; 을 붙여야 인식이 된다고한다. 설정 .env.development 1REACT_APP_HOST=localhost .env.production 1REACT_APP_HOST=192.168.0.1 사용 1${process.env.REACT_APP_HOST}</description></item><item><title>React - useEffect 사용법</title><link>https://bong-u.github.io/til/javascript/react_useeffect/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/react_useeffect/</guid><description> component가 rendering 될 때 실행 1useEffect(()=&amp;gt; { 2 ... 3}); component가 mount 될 때 (처음 rendering 될 때) 실행 1useEffect(()=&amp;gt; { 2 ... 3}, []); component가 update 될 때 (props, states가 바뀔 때) 실행 1useEffect(()=&amp;gt; { 2 ... 3}, [{ props or states }]); component가 unmount 될 때 또는 update되기 직전에 실행 1useEffect(()=&amp;gt; { 2 return () =&amp;gt; { 3 ... 4 }; 5}, []);</description></item><item><title>백준 - 17070 : 파이프 옮기기 1 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_17070/</link><pubDate>Thu, 19 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17070/</guid><description>1N = int(input()) 2 3L = [list(map(int, input().split())) for _ in range(N)] 4result = 0 5 6def dfs(x, y, direc): 7 global result 8 if x == N-1 and y == N-1: 9 result += 1 10 return 11 12 if x+1 &amp;lt; N and y+1 &amp;lt; N and L[y+1][x] == 0 and L[y][x+1] == 0 and L[y+1][x+1] == 0: 13 dfs(x+1, y+1, 2) 14 15 if (direc == 0 or direc == 2) and x+1 &amp;lt; N and L[y][x+1] == 0: 16 dfs(x+1, y, 0) 17 18 if (direc == 1 or direc == 2) and y+1 &amp;lt; N and L[y+1][x] == 0: 19 dfs(x, y+1, 1) 20 21dfs(1, 0, 0) 22print(result) 별거 아닌게.</description></item><item><title>MVC 1 : Request Mapping, Command Object, Redirect, Form Tag, Model</title><link>https://bong-u.github.io/til/spring/11_mvc_1/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/11_mvc_1/</guid><description>Request Mapping GetMapping/PostMapping으로 처리할 method를 지정하거나 RequestMapping을 사용할 수 있다. Access request parameter : HttpServletRequest 1@PostMapping(&amp;#34;/register/step2&amp;#34;) 2public String handleStep2(HttpServletRequest request) { 3 String agreeParam = request.getParameter(&amp;#34;agree&amp;#34;); 4 if (agreeParam == null || !agreeParam.equals(&amp;#34;true&amp;#34;)) { 5 return &amp;#34;register/step1&amp;#34;; 6 } 7 return &amp;#34;register/step2&amp;#34;; Access request parameter : RequestParam Annotation 1@PostMapping(&amp;#34;/register/step2&amp;#34;) 2public String handleStep2( 3@RequestParam(value=&amp;#34;agree&amp;#34;, defaultValue=&amp;#34;false&amp;#34;) Boolean agree) { 4 if (!agree) { 5 return &amp;#34;register/step1&amp;#34;; 6 } 7 return &amp;#34;register/step2&amp;#34;; Redirect 1@GetMapping(&amp;#34;/register/step2&amp;#34;) 2public String handleStep2Get() { 3 return &amp;#34;redirect:/register/step1&amp;#34;; Command Object Use request parameter as command object RegisterController.</description></item><item><title>React - column을 기준으로 정렬하기</title><link>https://bong-u.github.io/til/javascript/react_table_sort/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/javascript/react_table_sort/</guid><description>Table에 있는 데이터들을 column별로 정렬해야 한다 데이터의 형식에 따라 comparator를 따로 구현하였다 1const comparatorStr = (a, b, order) =&amp;gt; { 2 if (order === Order.ASC) return a.localeCompare(b); 3 return b.localeCompare(a); 4}; 5 6const comparatorInt = (a, b, order) =&amp;gt; { 7 if (order === Order.ASC) return a &amp;gt; b ? 1 : -1; 8 return a &amp;lt; b ? 1 : -1; 9}; 정렬할 키나 순서가 바뀔때 마다 정렬을 수행한다 1useEffect(() =&amp;gt; { 2 if (sortBy === Key.</description></item><item><title>백준 - 12852 : 1로 만들기 2 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_12852/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_12852/</guid><description>1N = int(input()) 2 3dp = [0, 0] + [10**6]*(N-1) 4bt = [0]*(N+1) 5 6for i in range(2, N+1): 7 dp[i] = min(dp[i-1]+1, dp[i]) 8 bt[i] = i-1 9 10 if i%3 == 0: 11 if dp[i//3]+1 &amp;lt; dp[i]: 12 dp[i] = dp[i//3]+1 13 bt[i] = i//3 14 if i%2 == 0: 15 if dp[i//2]+1 &amp;lt; dp[i]: 16 dp[i] = dp[i//2]+1 17 bt[i] = i//2 18 dp[i] = min(dp[i], dp[i//2]+1) 19 20print(dp[N]다 21i = N 22while i !</description></item><item><title>백준 - 2096 : 내려가기 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2096/</link><pubDate>Sat, 14 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2096/</guid><description>1N = int(input()) 2L = [list(map(int, input().split())) for _ in range(N)] 3dp1 = [L[0][i] for i in range(3)] 4dp2 = [L[0][i] for i in range(3)] 5 6for i in range(1, N): 7tmp1 = [0]*3 8tmp2 = [0]*3 9for j in range(3): 10 11 if j == 0: 12 tmp1[0] = L[i][j] + max(dp1[0], dp1[1]) 13 tmp2[0] = L[i][j] + min(dp2[0], dp2[1]) 14 elif j == 1: 15 tmp1[1] = L[i][j] + max(dp1[0], dp1[1], dp1[2]) 16 tmp2[1] = L[i][j] + min(dp2[0], dp2[1], dp2[2]) 17 else: 18 tmp1[2] = L[i][j] + max(dp1[1], dp1[2]) 19 tmp2[2] = L[i][j] + min(dp2[1], dp2[2]) 20 dp1 = [i for i in tmp1] 21 dp2 = [i for i in tmp2] 22 23print (max(dp1), min(dp2)) Memoization과정이 다른 memoization 변수에 대해 종속적이라면 잘못된 결과를 초래한다 위 코드에서는 이를 방지하기 위해 tmp1, tmp2 변수를 사용한다 깊이 생각하지 않고 여러 번 제출해서 WA개수가 조금 많다;;</description></item><item><title>백준 - 1890 : 점프 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1890/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1890/</guid><description>1N = int(input()) 2 3L = [list(map(int, input().split())) for _ in range(N)] 4dp = [[0]*N for _ in range(N)] 5dp[0][0] = 1 6for i in range(N): 7 for j in range(N): 8 if L[i][j] == 0: 9 continue 10 if dp[i][j] != 0: 11 right = j+L[i][j] 12 bottom = i+L[i][j] 13 14 if right &amp;lt; N: 15 dp[i][right] += dp[i][j] 16 if bottom &amp;lt; N: 17 dp[bottom][j] += dp[i][j] 18print (dp[N-1][N-1]) dp에 있는 값을 더해야하는데 1을 더해서 몇 번 틀렸다 거의 혼자 힘으로 풀었다</description></item><item><title>백준 - 1309 : 동물원 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_1309/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1309/</guid><description>1N = int(input()) 2dp = [1, 3] + [0]*(N-1) 3 4for i in range(2, N+1): 5 dp[i] = (dp[i-1]*2 + dp[i-2]) % 9901 6 7print(dp[N]) 고민 끝에 답을 찾아보긴 했다 점화식 생각해내는 놈들 머리에 뭐가 든건지 모르겠다</description></item><item><title>백준 - 9655 : 돌게임 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_9655/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_9655/</guid><description>1N = int(input()) 2print (&amp;#39;CY&amp;#39; if N%2==0 else &amp;#39;SK&amp;#39;) 게임이론에서 기초 중 기초 문제이다</description></item><item><title>08_connect_DB</title><link>https://bong-u.github.io/til/spring/08_connect_db/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/08_connect_db/</guid><description>DataSource 설정 AppCtx.java 1 @Bean(destroyMethod = &amp;#34;close&amp;#34;) 2 public DataSource dataSource() { 3 DataSource ds = new DataSource(); 4 ds.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); 5 ds.setUrl(&amp;#34;jdbc:mysql://localhost/spring5fs?&amp;#34;+ 6 &amp;#34;enabledTLSProtocols=TLSv1.2&amp;amp;&amp;#34;+ 7 &amp;#34;useSSL=false&amp;amp;&amp;#34;+ 8 &amp;#34;characterEncoding=utf8&amp;#34;); 9 ds.setUsername(&amp;#34;spring5&amp;#34;); 10 ds.setPassword(&amp;#34;spring5&amp;#34;); 11 ds.setInitialSize(2); 12 ds.setMaxActive(10); 13 ds.setTestWhileIdle(true); 14 ds.setMinEvictableIdleTimeMillis(60000 * 3); 15 ds.setTimeBetweenEvictionRunsMillis(10 * 1000); 16 return ds; 17 } Query 실행 JdbcTemplate을 이용한 select 1jdbcTemplate.query( 2&amp;#34;select * from MEMBER where EMAIL = ?&amp;#34;, 3new RowMapper&amp;lt;Member&amp;gt;() { 4 @Override 5 public Member mapRow(ResultSet rs, int rowNum) 6 throws SQLException { 7 Member member = new Member( 8 rs.</description></item><item><title>221207 SYSP</title><link>https://bong-u.github.io/til/school/sysp_09_11/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/sysp_09_11/</guid><description>09-process1 예외적인 제어 흐름 하위 매커니즘 예외 (Exception) 상위 매커니즘 프로세스 컨텍스트 전환 OS 소프트웨어와 하드웨어 타이머로 구현 시그널 OS 소프트웨어로 구현 nolocal 점프 예외 테이블 (Exception Tables) 각 이벤트 타입은 예외번호 k를 갖는다 비동기형 예외 (Interrupt) 입출력 인터럽트 (ctrl + c)
하드 리셋 인터러트
소프트 리셋 인터럽트</description></item><item><title>221208 SYSP</title><link>https://bong-u.github.io/til/school/sysp_12_13/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/sysp_12_13/</guid><description>12-memory-1 메모리에 관한 불편한 진실 메모리는 무한의 자원이 아니다 동적 메모리 할당 직접(explicit) vs 간접(implicit) 메모리 할당기 직접 할당 : 응용프로그램이 할당하고, 반환한다 ex) malloc, free 간접 할당 : 응용프로그램이 할당하지만, 반환하지는 않는다 ex) java의 garbage collector 프로세스의 메모리 이미지 스택은 아래로, 힙은 위로 성장한다 sbrk 함수가 추가적인 힙 메모리를 운영체제로부터 요청한다 (brk 포인터 이동) Malloc package 1#include &amp;lt;stdlib.</description></item><item><title>Spring 개념 - AOP (Aspect Oriented Programming)</title><link>https://bong-u.github.io/til/spring/aop/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/aop/</guid><description>AOP (Aspect Oriented Programming) 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법 기본 개념 : 핵심 기능에 공통 기능을 삽입 구현하는 3가지 방법 컴파일 시점에 코드에 공통 기능을 삽입하는 방법 클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법 런타임에 프록시 객체를 생성해서 공통 기능을 삽입하는 방법 AOP 주요 용어 Target 부가 기능을 부여할 대상
Advice 부가기능을 담고 있는 모듈</description></item><item><title>객체지향설계</title><link>https://bong-u.github.io/til/school/ood/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/ood/</guid><description>Dynamic dispatch and Multiple inheritance Polymorphism Function overloading using compile time types of arguments Function overriding using runtime types of receiver objects virtual function for dynamic dispatch dynamic dispatch를 사용하기 위한 조건
함수가 virtual keyword로 정의되어 있어야 한다.
receiver object가 포인터(*), 참조(&amp;amp;)를 통해 refer되어야 한다
1// from parent class : Employee 2virtual std::string GetInfo() { 3 return &amp;#34;Employee: &amp;#34; + name_ ; 4} 5// from child class : Developer 6std::string GetInfo() { 7 return &amp;#34;Developer: &amp;#34; + name_; 8} override keyword override 키워드를 사용하는 이유 직관적인 코드</description></item><item><title>백준 - 1010 : 다리놓기 (S5)</title><link>https://bong-u.github.io/til/algorithm/boj_1010/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1010/</guid><description>1import math 2 3for _ in range(int(input())): 4 a, b = map(int, input().split()) 5 print(math.comb(max(a,b), min(a,b)))</description></item><item><title>백준 - 10844 : 쉬운 계단 수 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_10844/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_10844/</guid><description> 접근이 어려워 인터넷을 참고했다. 코드는 보지 않았다. 수의 길이가 i이면서 마지막 숫자가 j인 계단 수의 개수를 저장하는 것이 핵심이다. 점화식은 L[i][j] = L[i-1][j-1]+L[i-1][j+1] 이다. 1N = int(input()) 2L = [[0]*12 for _ in range(100)] 3L[0] = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0] 4 5for i in range(1, N): 6 for j in range(1, 11): 7 L[i][j] = L[i-1][j-1]+L[i-1][j+1] 8 9print (sum(L[N-1])%1000000000)</description></item><item><title>백준 - 11048 : 이동하기 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_11048/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11048/</guid><description>1N, M = map(int, input().split()) 2dp = [list(map(int, input().split())) for _ in range(N)] 3 4for i in range(1, N): 5 dp[i][0] = dp[i][0]+dp[i-1][0] 6for i in range(1, M): 7 dp[0][i] = dp[0][i]+dp[0][i-1] 8 9for i in range(1, N): 10 for j in range(1, M): 11 dp[i][j] = dp[i][j]+max(dp[i-1][j], dp[i][j-1]) 12 13print (dp[N-1][M-1])</description></item><item><title>백준 - 11051 : 이항계수2 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_11051/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11051/</guid><description> 내장 함수 사용
1import math 2 3N, K = map(int, input().split()) 4 5print (math.comb(N, K)%10007 파스칼의 사각형? dp 구현
1N, K = map(int, input().split()) 2 3if K == 0: 4 print(1) 5 exit() 6 7dp = [[0]*N for _ in range(K)] 8 9for i in range(N): 10 dp[0][i] = i+1 11 12for i in range(1, K): 13 for j in range(i, N): 14 dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % 10007 15 16print (dp[K-1][N-1])</description></item><item><title>백준 - 11052 : 카드 구매하기 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_11052/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11052/</guid><description>1N = int(input()) 2P = list(map(int, input().split())) 3 4D = [P[0]]+[0]*(N-1) 5 6for i in range(1, N): 7 for j in range(1, i+1): 8 D[i] = max(D[i-j]+P[j-1], D[i]) 9 D[i] = max(P[i], D[i]) 10 11print (D[N-1]</description></item><item><title>백준 - 11057 : 오르막 수 (S1)</title><link>https://bong-u.github.io/til/algorithm/boj_11057/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_11057/</guid><description>1N = int(input()) 2dp = [[1]+[0]*9 for _ in range(N+1)] 3 4for i in range(1, N+1): 5 for j in range(1, 10): 6 dp[i][j] = dp[i-1][j]+dp[i][j-1] 7 8print (sum(dp[N])%10007)</description></item><item><title>백준 - 14891 : 톱니바퀴 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_14891/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_14891/</guid><description>1from collections import deque 2 3wheels = [deque(map(int, list(input()))) for _ in range(4)] 4 5def rotate(wheel, direction): 6 if direction == 1: 7 wheel.appendleft(wheel.pop()) 8 else: 9 wheel.append(wheel.popleft()) 10 return wheel 11 12K = int(input()) 13vd = [1, -1] 14res = 0 15 16for _ in range(K): 17 N, D = map(int, input().split()) 18 q = deque() 19 q.append((N-1, D)) 20 visited = [False] * 4 21 tmp = [] 22 23 while q: 24 cur, curD = q.</description></item><item><title>백준 - 15683 : 감시 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_15683/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_15683/</guid><description>1import copy, sys 2 3N, M = map(int, input().split()) 4L = [list(map(int, input().split())) for _ in range(N)] 5cctv = [] 6direction = [[[(0, 1)], [(0, -1)], [(1, 0)], [(-1, 0)]], 7[[(-1, 0), (1, 0)], [(0, -1), (0, 1)]], 8[[(-1, 0), (0, -1)], [(0, -1), (1, 0)], [(1, 0), (0, 1)], [(0, 1), (-1, 0)]], 9[[(-1, 0), (0, -1), (1, 0)], [(0, -1), (1, 0), (0, 1)], [(1, 0), (0, 1), (-1, 0)], [(0, 1), (-1, 0), (0, -1)]], 10[[(-1, 0), (0, -1), (1, 0), (0, 1)]]] 11res = sys.</description></item><item><title>백준 - 1699 : 제곱수의 합 (S2)</title><link>https://bong-u.github.io/til/algorithm/boj_1699/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_1699/</guid><description>1N = int(input()) 2 3dp = [100000]*(N+1) 4tmp = 1 5 6for i in range(1, N+1): 7 if i**(1/2) % 1 == 0: 8 dp[i] = 1 9 tmp += 1 10 else: 11 for j in range(1, tmp): 12 dp[i] = min(dp[i], dp[i-(j**2)]+1) 13 14print (dp[N])</description></item><item><title>백준 - 17404 : RGB거리 2 (G4)</title><link>https://bong-u.github.io/til/algorithm/boj_17404/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_17404/</guid><description>1N = int(input()) 2L = [list(map(int, input().split())) for _ in range(N)] 3 4result = 100000 5 6for i in range(3): 7 dp = [[0, 0, 0] for _ in range(N)] 8 dp[0] = [10000]*3 9 dp[0][i] = L[0][i] 10 for j in range(1, N): 11 dp[j][0] = min(dp[j-1][1], dp[j-1][2])+L[j][0] 12 dp[j][1] = min(dp[j-1][0], dp[j-1][2])+L[j][1] 13 dp[j][2] = min(dp[j-1][0], dp[j-1][1])+L[j][2] 14 15 dp[N-1][i] = 100000 16 result = min([result]+dp[N-1]) 17 18print (result) 인터넷을 참고하여 풀었다</description></item><item><title>백준 - 2193 : 이친수 (S3)</title><link>https://bong-u.github.io/til/algorithm/boj_2193/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2193/</guid><description>1N = int(input()) 2dp = [1]*N 3for i in range(2, N): 4 dp[i] = dp[i-2]+dp[i-1] 5print (dp[N-1]) 피보나치였다</description></item><item><title>백준 - 2225 - 합분해 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2225/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2225/</guid><description>1N, K = map(int, input().split()) 2 3dp = [[0]*(N+1) for _ in range(K+1)] 4for i in range(1, K+1): 5 dp[i][0] = 1 6 7for i in range(1, K+1): 8 for j in range(1, N+1): 9 dp[i][j] = (dp[i-1][j] + dp[i][j-1])%1000000000 10print (dp[K][N]) 내 힘으로 풀었다!</description></item><item><title>백준 - 2294 : 동전 2 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2294/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2294/</guid><description>1N, K = map(int, input().split()) 2V = [] 3for _ in range(N): 4 V.append(int(input())) 5dp = [[0]+([10001]*K) for _ in range(N+1)] 6 7for i in range(1, N+1): 8 for j in range(1, K+1): 9 if j &amp;gt;= V[i-1]: 10 dp[i][j] = min(dp[i-1][j], dp[i][j-V[i-1]]+1) 11 else: 12 dp[i][j] = dp[i-1][j] 13 14res = dp[N][K] 15 16print (res if res != 10001 else -1) dp를 많이 풀어보자</description></item><item><title>백준 - 2565 : 전깃줄 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2565/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2565/</guid><description>1N = int(input()) 2L = [list(map(int, input().split())) for _ in range(N)] 3L = [i[1] for i in sorted(L)] 4dp = [0]*N 5for i in range(N): 6 dp[i] = 1 7 for j in range(i): 8 if L[j] &amp;lt; L[i]: 9 dp[i] = max(dp[i], dp[j]+1) 10 11print (N-max(dp)) LIS를 이용하는 문제</description></item><item><title>백준 - 2573 : 빙산 (G5)</title><link>https://bong-u.github.io/til/algorithm/boj_2573/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2573/</guid><description>1import copy 2from collections import deque 3 4N, M = map(int, input().split()) 5L = [list(map(int, input().split())) for _ in range(N)] 6L[0][0] = 0 7L[N-1][M-1] = 0 8vx = [0, 0, -1, 1] 9vy = [-1, 1, 0, 0] 10 11def melt(L): 12 L_ = copy.deepcopy(L) 13 for i in range(M): 14 for j in range(N): 15 if L[j][i] != 0: 16 for k in range(4): 17 nx = j + vx[k] 18 ny = i + vy[k] 19 20 if not 0 &amp;lt;= nx &amp;lt; N or not 0 &amp;lt;= ny &amp;lt; M: 21 continue 22 if L[nx][ny] == 0 and L_[j][i] !</description></item><item><title>백준 - 2748 : 피보나치 수2 (B2)</title><link>https://bong-u.github.io/til/algorithm/boj_2748/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/algorithm/boj_2748/</guid><description> &amp;ldquo;알고리즘 분류-DP&amp;quot;에서 안 푼 문제이길래 한 번 풀어봤다. 1N = int(input()) 2 3L = [0, 1] + [0]*89 4 5for i in range(2, N+1): 6 L[i] = L[i-1]+L[i-2] 7 8print (L[N])</description></item><item><title>현대인의 생활문화</title><link>https://bong-u.github.io/til/school/mplc/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/mplc/</guid><description>글로벌 매너 매너 인간관계를 맺는데 있어 중요한 요소
어원 : Manus(손, 행동, 습관) + Arius(방법, 방식)
매너의 기본(1)
다른 사람의 인격을 존중하고, 배려하는 마음을 가지고, 편안하게 해주거나 기쁘게 만들려는 행동방식
매너의 기본(2)
역지사지 (易地思之)
매너의 기본(3)
형식에 치우치지 말고, 배려하는 마음을 전달하는 것
매너와 에티켓의 차이 매너(예의) : 상황에 따라 다르게 표현 가능 에티켓(범절) : 형식과 절차를 중요시 함 동양의 매너 5덕</description></item><item><title>09_spring_MVC</title><link>https://bong-u.github.io/til/spring/09_spring_mvc/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/09_spring_mvc/</guid><description>Spring MVC 시작하기 프로젝트 생성 앞에서 만들었던 자바 애플리케이션과는 좀 다른점이 있었다 jar이 아닌 war을 사용하는 등 여러가지 많았는데 일일이 적지는 않을 것이다 Controller 1@Controller 2public class HelloController { 3 @GetMapping(&amp;#34;/hello&amp;#34;) 4 public String hello(Model model, 5 @RequestParam(value=&amp;#34;name&amp;#34;, required=false) String name) { 6 model.addAttribute(&amp;#34;greeting&amp;#34;, &amp;#34;안녕하세요&amp;#34; + name); 7 return &amp;#34;hello&amp;#34;; 8 } 9} JSP 1&amp;lt;%@ page contentType=&amp;#34;text/html; charset=utf-8&amp;#34; %&amp;gt; 2&amp;lt;!DOCTYPE html&amp;gt; 3&amp;lt;html&amp;gt; 4 &amp;lt;head&amp;gt; 5 &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; 6 &amp;lt;/head&amp;gt; 7 &amp;lt;body&amp;gt; 8 인사말 : ${greeting} 9 &amp;lt;/body&amp;gt; 10&amp;lt;/html URL접속해도 해당 jsp파일이 나오지 않는 문제 vscode에서 community server connector라는 extension을 통해 tomcat을 띄워서 할려고 한다 특정 jsp를 감지했는지, serving하는지에 대한 로그가 없어 되는건지 알 수가 없다 web.</description></item><item><title>Spring 개념 - Autowired</title><link>https://bong-u.github.io/til/spring/autowired/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/autowired/</guid><description>@Autowired를 이용한 자동 객체 주입 방법1 : Field에 적용
1public class MemberListPrinter { 2 @Autowired 3 private MemberDao memberDao; 4 @Autowired 5 private MemberPrinter printer; 6 7 public MemberListPrinter() {} 8 9 public void printAll() { 10 Collection&amp;lt;Member&amp;gt; members = memberDao.selectAll(); 11 members.forEach(m -&amp;gt; printer.print(m)); 12 } 13} 방법2 : Method에 적용
1public class MemberListPrinter { 2 private MemberDao memberDao; 3 private MemberPrinter printer; 4 5 public MemberListPrinter() {} 6 7 @Autowired 8 public void setMemberDao(MemberDao memberDao) { 9 this.</description></item><item><title>Spring 개념 - Bean Lifecycle &amp; Scope</title><link>https://bong-u.github.io/til/spring/bean_lifecycle_scope/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/bean_lifecycle_scope/</guid><description>Bean 객체의 Lifecycle Bean 객체가 생성 또는 소멸될때 특정 코드를 실행하게 할 수 있다. @PostConstruct, @PreDestroy Annotation 사용
1// Bean 객체 생성될 때 실행 2@PostConstruct 3public void postConstruct() {...} 4 5// Bean 객체 소멸될 때 실행 6@PreDestroy 7public void preDestroy() {...} InitializingBean, DisposableBean 구현
1public class Client implements InitializingBean, DisposableBean { 2 // Bean 객체 생성될 때 실행 3 @Override 4 public void afterPropertiesSet() throws Exception {.</description></item><item><title>Spring 개념 - Component Scan</title><link>https://bong-u.github.io/til/spring/component_scan/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/component_scan/</guid><description>개념 Component Scan은 스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능이다 xml 또는 annotation을 통해 사용 가능하다 @ComponentScan basePacakges : 패키지 이름을 통해 스캔할 범위를 지정한다
1@ComponentScan(basePackages=&amp;#34;org.academy.order&amp;#34;) 2@ComponentScan(basePackages={&amp;#34;org.academy.order&amp;#34;, &amp;#34;org.academy.voucher&amp;#34;}) basePackageClasses : 해당 클래스가 들어있는 패키지를 범위로 지정한다
1@ComponentScan(basePackageClasses=&amp;#34;Order.class&amp;#34;) 2@ComponentScan(basePackages={&amp;#34;Order.class&amp;#34;, &amp;#34;Voucher.class&amp;#34;}) 예제 AppCtx.java
1@Configuration 2@ComponentScan(basePackages = {&amp;#34;spring&amp;#34;}) 3public class AppCtx {...} MemberInfoPrinter.java
1@Component(&amp;#34;infoPrinter&amp;#34;) 2public class MemberInfoPrinter {...} 효과</description></item><item><title>Spring 개념 - DI (Dependency Injection)</title><link>https://bong-u.github.io/til/spring/di/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/di/</guid><description>의존 주입 (DI : Dependency Injection)을 하는 방법 Assembler라는 별도의 클래스 생성
1public class Assembler { 2 private MemberDao memberDao; 3 private MemberRegisterService regSvc; 4 5 public Assembler() { 6 memberDao = new MemberDao(); 7 regSvc = new MemberRegisterService(memberDao); 8 } 9 10 public MemberDao getMemberDao() { 11 return memberDao; 12 } 13 14 public MemberRegisterService getMemberRegisterService() { 15 return regSvc; 16 } 17} Spring에서 지원하는 DI 사용</description></item><item><title>Spring 개념 - Testing</title><link>https://bong-u.github.io/til/spring/testing/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/spring/testing/</guid><description>Unit Test (단위 테스트) 가장 작은 단위 (클래스 또는 메소드)를 고립시켜서 테스트하는 방식
관련 용어 SUT (Sytem Under Test) 테스트하고자하는 주요 대상이 되는 Unit
DOC (Depended On Component) SUT가 의존하는 객체
Test double DOC를 대신해 줄 수 있는 객체
Test double의 종류 : Mock, Stub Mock 행위 검증 (객체가 특정 동작을 수행하는지 검증) 사용 test framework : Mockito, JMock, EasyMock Stub 상태 검증 (객체의 상태를 확인하여 검정) 사용 Integration Test (통합 테스트) 여러 개의 Unit을 통합해서 테스트하는 방식</description></item></channel></rss>