<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cs on bong-u/til</title><link>https://bong-u.github.io/til/tags/cs/</link><description>Recent content in cs on bong-u/til</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 02 Jul 2025 00:00:00 +0900</lastBuildDate><atom:link href="https://bong-u.github.io/til/tags/cs/index.xml" rel="self" type="application/rss+xml"/><item><title>정보처리기사 실기 준비</title><link>https://bong-u.github.io/til/etc/ipe_practical/</link><pubDate>Wed, 02 Jul 2025 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/ipe_practical/</guid><description> 볼드체의 개념은 기출 문제에서 등장, 나머지 개념은 모의고사에서 등장 SW 공학 관련 개념 SOLID 원칙 S : 단일 책임 원칙 (SRP) O : 개방 폐쇄 원칙 (OCP) : 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다는 원칙 L : 리스코프 치환 원칙 (LSP) : 서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다는 원칙 I : 인터페이스 분리 원칙 (ISP) D : 의존 역전 원칙 (DIP) : 추상화에 의존해야 한다는 원칙 SOA(Service-Oriented Architecture) : 서비스 지향 아키텍처 Walk Through : 검토 자료를 회의 전에 배포해서 사전검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 오류를 검출하고 문서로 만드는 기법 정형 명세 기법 : 사용자의 요구를 표현할 때 수학적 원리와 표기법으로 서술하는 기법 Abstract Factory Pattern : 생성 패턴; 객체 생성에 대한 인터페이스를 제공하고, 구체적인 클래스는 서브클래스에서 정의하는 패턴 Decorator Pattern : 구조 패턴; 객체에 추가적인 책임을 동적으로 부여하는 패턴 Memento Pattern : 행동 패턴; 객체의 상태를 저장하고 복원하는 패턴 이상 현상 : 데이터를 데이터베이스에 저장할때 불필요하게 중복되어 릴레이션 조작시 예기치 못한 곤란한 현상일 발생하는 현상 번다운 차트 : 남은 작업량을 시간에 따라 표시하여 진행 상황을 시각적으로 나타내는 차트 COCOMO : 보헴이 제안한 프로그램 규모에 따라 비용을 산정하는 방식 (조직형, 분리형, 임베디드형) CPM : 프로젝트의 작업을 네트워크 형태로 표현하여 전체 프로젝트의 일정을 계산하는 알고리즘 PERT : 비관치, 중관치, 낙관치의 3점 추정 방식을 통해 일정을 관리하는 기법 결함 집중 : 20%의 모듈에서 80%의 결함이 발생한다는 원리 살충제 패러독스 : 동일한 테스트 케이스를 반복적으로 실행하면 새로운 결함을 발견하지 못한다는 원리 배치 다이어그램 : 시스템의 물리적인 구조를 보여주는 다이어그램, 어떤 SW가 어떤 HW에 배치되는지를 나타냄 패키지 다이어그램 : 시스템의 패키지 구조를 나타내는 다이어그램 브룩스의 법칙 : &amp;ldquo;늦어진 프로젝트에 인력을 추가하면 오히려 더 늦어진다&amp;quot;는 법칙 네트워크 관련 개념 Hub &amp;amp; Spoke : EAI 구축 유형; 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식 MQTT : IoT 장치 간 통신에 사용되는 경량 메시징 프로토콜 CoAP : M2M 노드들 사이에서 이벤트에 대한 송수신을 비동기적으로 전송하는 REST 기반의 프로토콜 거리 벡터 알고리즘 : 네트워크 라우팅 프로토콜의 한 종류; 각 노드가 자신의 거리와 이웃 노드의 거리 정보를 교환하여 최적 경로를 찾는 알고리즘 링크 상태 알고리즘 : 네트워크 라우팅 프로토콜의 한 종류; 각 노드가 전체 네트워크의 상태 정보를 수집하여 최적 경로를 찾는 알고리즘 회선 제어 : 두 개의 스테이션이 동시에 신호를 전송하는 경우 충돌이 발생하지 않도록 제어하는 기술 Slowris : 다량의 HTTP 연결을 동시에 열고 유지하는 DoS RUDY : 느린 속도로 양식 데이터를 제출하여 연결 상태를 유지하는 것을 목표로 하는 DoS Slow Http read Dos : HTTP 요청 패킷의 헤더를 변조하여 웹 서버에 보내 연결 상태를 유지하게 하는 DoS SNMP(Simplified Network Management Protocol) : 네트워크 장비의 상태를 모니터링하고 관리하기 위한 프로토콜 DHCP(Dynamic Host Configuration Protocol) : 네트워크 장치에 IP 주소를 자동으로 할당하는 프로토콜 RARP (Reverse Address Resolution Protocol) : MAC 주소 -&amp;gt; IP 주소 변환 프로토콜 보안 관련 개념 kill switch : 스마트폰 이용자가 도난당한 스마트폰의 작동을, 웹사이트를 통해 정지할 수 있도록 하는 일종의 자폭 기능 제로 데이 공격 : 보안 취약점이 알려지기 전에 해당 취약점을 악용하여 이루어지는 공격 ARP Spoofing : ARP 프로토콜을 이용하여 네트워크 상의 다른 호스트의 MAC 주소를 위조하는 공격 기법 디지털 포렌식 : 디지털 기기에서 발생한 범죄나 사고의 증거를 수집, 분석, 보존하는 과정 루트킷 : 시스템에 몰래 설치되어 사용자의 권한을 탈취하거나 시스템을 제어하는 악성 소프트웨어 스피어 피싱 : 특정 개인이나 조직을 대상으로 하는 맞춤형 피싱 공격 APT 공격 : 특정 타깃을 목표로 다양한 수단을 통한 지속적이고 지능적인 맞춤혐 공격 기법 SET(Secure Electronic Transaction) : 전자 상거래에서 안전한 결제를 위한 프로토콜 사이버 킬체인 : 록히드 마틴의 공격형 방위 시스템 DAC (Discretionary Access Control) : 사용자가 자유롭게 객체에 대한 접근 권한을 관리할 수 있는 방식 MAC (Mandatory Access Control) : 시스템 관리자가 정책에 따라 사용자에게 접근 권한을 부여하는 방식 데이터베이스 관련 개념 낙관적 검증 : 트랜잭션을 일단 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스 반영하는 기법 2PC (Two-Phase Commit) : 분산 데이터베이스 시스템에서 트랜잭션의 원자성을 보장하기 위해 두 단계로 커밋을 수행하는 방식 완전 함수 종속 : 릴레이션의 모든 속성이 기본키에만 종속되는 상태 이행 함수 종속 : A-&amp;gt;B, B-&amp;gt;C 이면 A-&amp;gt;C가 성립하는 상태 체크포인트 회복 기법 : 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애를 복구하는 기법 OS 관련 개념 마이크로커널 : 다양한 서비스를 Kernel Mode가 아닌 User Mode에서 처리하는 초소형 커널 프로세스 스케쥴링 SJF(Shortest Job First) : 가장 짧은 작업을 먼저 처리하는 방식 HRN (Highest Response Ratio Next) : 대기 시간과 서비스 시간을 고려하여 우선순위를 결정하는 방식 피터슨 알고리즘 : 두 프로세스 간의 상호 배제를 보장하는 알고리즘; 플랙그와 턴을 사용하여 상호 배제와 진입 허용을 구현 기타 개념 피코넷 : 여러 개의 독립된 장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술 지그비 :저속 전송 속도를 갖는 홈오토메이션 및 데이터 네트워크를 위한 표준 기술 클리어링 하우스 : 디지털 저작권 라이선싱을 중개하고 라이선스 발급을 수행하는 정산소 데이터 마트 : 데이터의 한 부분으로서 특정 사용자가 관심을 갖는 데이터들을 담은 비교적 작은 규모의 데이터 웨어하우스 OLAP : 온라인 분석 처리; 데이터 웨어하우스의 데이터를 전략적인 정보로 변환시켜서 의사결정을 지원하는 역할 수행 semantic web : 웹 상의 정보에 의미를 부여하여 기계가 이해할 수 있도록 하는 기술 온톨로지(Ontology) : 특정 도메인에 대한 개념과 그들 간의 관계를 정의하는 명세 디지털 아카이빙 : 디지털 자료를 장기적으로 보존하고 관리하는 과정 CEP(Complex Event Processing) : 실시간으로 대량의 이벤트를 처리하고 분석하는 기술 노모포비아 : 스마트폰을 잃어버리거나 사용할 수 없는 상황에 대한 불안감 ITIL(Information Technology Infrastructure Library) : 영국 정부가 다양한 IT 서비스들의 관리 방법들을 모아 만든 표준적인 참고 문서 데이터 마이닝 : 대량의 데이터에서 유용한 정보를 추출하는 과정 오픈 스택 : 아파치 라이선스로 배포되는 클라우드 플랫폼 프로젝트 BCP(Business Continuity Planning) : 재해 발생 시 비즈니스 운영을 지속하기 위한 계획 Trust Zone : ARM에서 개발한 보안 기술로, 하드웨어 기반의 보안 영역을 제공하여 민감한 데이터를 보호하는 기술 WSDL (Web Services Description Language) : 웹 서비스의 기능을 기술하는 XML 기반의 언어 EAI : 기업 내 다양한 시스템 간의 데이터 통합 및 상호 운용성을 위한 솔루션 SQL LIKE 문법 % : 0개 이상의 문자열과 일치 [ ] : 1개의 문자와 일치 [^ ] : 1개의 문자와 불일치 _ : 특정 위치의 1개 문자와 일치</description></item><item><title>정보처리기사 필기 준비</title><link>https://bong-u.github.io/til/etc/ipe_written/</link><pubDate>Wed, 07 May 2025 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/etc/ipe_written/</guid><description>1과목 : 소프트웨어 설계 결합도 자료 결합도 : 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도 스탬프 결합도 : 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도 제어 결합도 : 한 모듈이 다른 모듈과 제어 신호를 이용하여 통신하고, 공유되는 공통 데이터 영역을 사용할 때의 결합도 외부 결합도 : 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도 공유 결합도 : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 내용 결합도 : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도 응집도 순차적 응집도 (Sequential Cohesion) 교환적 응집도 (Communicational Cohesion) 절차적 응집도 (Procedural Cohesion) 시간적 응집도 (Temporal Cohesion) 논리적 응집도 (Logical Cohesion) 우연적 응집도 (Coincidental Cohesion) 유스케이스(Use Case)의 구성 요소 간의 관계 연관 관계 포함 관계 확장 관계 일반화 관계 자료흐름도의 각 요소별 표기 형태 Process : 원 Data Flow : 화살표 Data Store : 평행선 Terminator : 사각형 추상화의 종류 자료 추상화 과정 추상화 제어 추상화 UML 모델에서의 관계 Aggregation : 집합 관계 Generalization : 일반화 관계 Composition : 포함 관계 Dependency : 의존 관계 Realization : 실체화 관계 2과목 : 소프트웨어 개발 법칙 파레토 법칙 : 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙 해싱함수 종류 제산법, 제곱법, 폴딩법, 기수 변환법, 대수적 코딩법, 계수 분석법(숫자 분석법), 무작위법</description></item><item><title>JIT 컴파일러와 AOT 컴파일러</title><link>https://bong-u.github.io/til/java/jit_aot/</link><pubDate>Mon, 16 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/jit_aot/</guid><description>JIT(Just-In-Time) 컴파일러 프로그램이 실행 중일때, 바이트 코드를 네이티브 코드로 컴파일하는 컴파일러
주요 작업 Hotspot(자주 실행되는 코드)을 탐지 최적화 수준 결정 최적화 및 컴파일 네이티브 코드 생성 캐싱 : 네이티브 코드를 캐싱하여 재사용 AOT(Ahead-Of-Time) 컴파일러 프로그램이 실행되기 전에, 바이트 코드를 네이티브 코드로 컴파일하는 컴파일러
인터프리터 방식 X, 컴파일 방식 O 실행 속도가 빠름 GraalVM을 사용하면 Java 프로그램을 AOT 컴파일 가능 GraalVM 오라클에서 개발한 JVM 기반의 다양한 언어를 지원하는 통합 실행 환경 (JVM, JDK)</description></item><item><title>Python의 동작 원리</title><link>https://bong-u.github.io/til/python/interpreter/</link><pubDate>Mon, 16 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/interpreter/</guid><description>파이썬의 구현체 CPython 파이썬의 표준 구현체이자 인터프리터
역할 파이썬 코드를 바이트 코드로 변환 바이트 코드를 실행 파이썬 바이트 코드 .pyc 파일에 저장 플랫폼에 독립적 파이썬 가상 머신(PVM)에서 실행 예시 4 0 LOAD_GLOBAL 0 (print) 2 LOAD_CONST 1 ('hello world') 4 CALL_FUNCTION 1 6 POP_TOP 5 8 LOAD_CONST 2 (True) 10 RETURN_VALUE Jython 파이썬 코드를 자바 바이트 코드로 변환, JVM에서 실행</description></item><item><title>JVM(Java Virtual Machine)</title><link>https://bong-u.github.io/til/java/jvm/</link><pubDate>Fri, 13 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/java/jvm/</guid><description> 자바 바이트 코드를 실행할 수 있는 가상 머신
JVM의 구조 클래스 로더 (Class Loader) 로딩 (Loading) : .class 파일을 읽어들여 메모리에 적재 링크 (Linking) : 적재된 클래스의 참조를 확인하고 준비 초기화 (Initialization) : static 블록과 static 변수 초기화 실행 엔진 (Execution Engine) 클래스 로더가 메모리에 적재된 바이트 코드를 실행하는 역할 인터프리터 (Interpreter) 바이트 코드를 명령어 단위로 읽어서 실행 JIT 컴파일러 (Just-In-Time Compiler) Runtime 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경 후 실행 -&amp;gt; 성능 향상 GC (Garbage Collector) 더 이상 사용하지 않는 메모리를 해제하는 역할 런타임 데이터 영역 (Runtime Data Area) PC(Program Counter) 스레드가 실행되는 부분의 주소를 가리키는 포인터 JVM 스택 (JVM Stack) 메소드 호출 시마다 프레임을 추가하고, 메소드가 종료되면 해당 프레임을 제거 각 프레임은 로컬 변수, 연산 스택, 메소드 수행이 끝나면 종료되는 정보를 저장 Native 메소드 스택 JNI(Java Native Interface)를 통해 호출되는 C/C++/Assembly와 같은 네이티브 코드를 위한 스택 힙 (Heap) new 키워드로 생성된 객체와 배열을 저장하는 공간 메소드 영역 (Method Area) 클래스 정보, 상수, 정적 변수 등을 저장하는 공간 모든 쓰레드가 공유하는 공간 -&amp;gt; 멀티쓰레딩 시 동기화 처리 필요</description></item><item><title>Python의 GIL</title><link>https://bong-u.github.io/til/python/gil/</link><pubDate>Fri, 13 Dec 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/python/gil/</guid><description>GIL(Global Interpreter Lock) 하나의 쓰레드만 파이썬 바이트코드를 실행할 수 있도록 하는 것
파이썬의 표준 구현인 CPython에서만 존재 장점 Reference Counting 기반 메모리 관리의 Race condition 방지 데이터 무결성 보장 : 멀티쓰레드 환경에서 파이썬 객체나 메모리 관련 작업이 안전하게 수행되도록 보장 파이썬 Interpreter의 구현을 단순화 : 복잡한 락 메커니즘이 필요없음 C 확장 모듈이 Thread-Safe 하지 않더라도 안전하게 사용할 수 있도록 보장 플랫폼 독립성 유지 : CPU 아키텍처별 동기화 메커니즘에 의존하지 않음 단점 멀티코어 CPU 활용 제한: 단일 코어만 사용되므로 병렬 처리의 이점을 얻을 수 없음 멀티쓰레딩 성능 저하 : 쓰레드 간 context switching이 빈번하게 발생 공정성 문제 : 특정 쓰레드가 GIL을 장시간 점유하면 starvation 문제가 발생할 수 있음 Reference Counting 객체가 몇 번 참조되는지를 세어서 0이 되면 메모리를 해제하는 방식</description></item><item><title>네트워크 보안</title><link>https://bong-u.github.io/til/school/network_security/</link><pubDate>Wed, 05 Jun 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/network_security/</guid><description>네트워크 보안 개요 네트워크 보안의 요구사항 기밀성(Confidentiality) 정보를 권한이 없는 개인에게 노출되지 않도록 함
무결성(Integrity) 정보와 프로그램은 인가된 방식으로만 변경되도록 함
가용성(Availability) 정보 자산에 대해 적절한 시간에 접근 가능하도록 함
보안 공격의 종류 소극적 공격(Passive Attack) 정보를 도청하거나 감시하는 공격 방어방법 : 암호화 적극적 공격(Active Attack) 정보를 변조하거나 삭제하는 공격 방어방법 : 메시지 인증 보안 서비스 인증(Authentication) 사용자의 신원을 확인하는 과정</description></item><item><title>프로그래밍언어개론</title><link>https://bong-u.github.io/til/school/plt/</link><pubDate>Sun, 14 Apr 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/plt/</guid><description>Ocaml Functional Programming 함수형 프로그래밍은 함수를 값처럼 다루는 프로그래밍 패러다임
특징 Immutable 변수의 값이 변하지 않는다
First-class function Higher-order function Referential transparency 동일한 인자에 대해 항상 동일한 결과를 반환한다
Lazy evaluation (지연 계산) 필요할 때만 계산을 수행
Primitive Types unit int float int_of_float : float-&amp;gt;int float_of_int : int-&amp;gt;float bool : true/false x = y : x equals y (structural equality) x &amp;lt;&amp;gt; y : x not equals y (structural equality) x == y : x equals y (physical equality) x !</description></item><item><title>웹 보안</title><link>https://bong-u.github.io/til/school/web_security/</link><pubDate>Mon, 11 Mar 2024 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/web_security/</guid><description>Web Security Model Web 보안의 목표 Integirty : 무결성 Confidentiality : 기밀성 HTTP URL https:// www.example.edu :80 /lectures ?lec=80 #slides protocol + hostname + port + path + query + fragment
Cookies 서버가 웹 브라우저에게 보내는 정보
역할 : 세션 관리, 사용자 설정 저장, 사용자 추적 등 1// 쿠키 설정 2Set-Cookie: name=value; 3// 쿠키 전송 4Cookie: name=value; Same Origin Policy (SOP) 같은 Origin에서만 리소스를 공유할 수 있도록 한다</description></item><item><title>소프트웨어공학</title><link>https://bong-u.github.io/til/school/software_engineering/</link><pubDate>Tue, 24 Oct 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/software_engineering/</guid><description>1장 소프트웨어 공학 개요 소프트웨어의 종류 주문형, 패키지형, 임베디드 시스템 실시간 소프트웨어, 자료처리 소프트웨어 소프트웨어 공학의 정의 IEEE : 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 W.Humphrey : 질 좋은 소프트웨어를 경제적으로 생산하기 위하여 공학, 과학, 수학적 원리에 의하여 소프트웨어를 개발해야한다 소프트웨어 품질 (효-용-신-유-재-) 효율성(efficiency) 사용용이성(usability) 신뢰성(reliability) 유지보수성(maintainability) 재사용성(reusability) 소프트웨어 프로젝트 작업 요구분석과 명세화 도메인 분석, 문제 정의, 요구 추출, 요구 분석, 요구 명세화 설계 : 가용한 기술로 어떻게 구현되어야하는지 기술 시스템 엔지니어링, 소프트웨어 아키텍쳐 UI 설계, DB 설계 모델링 : 도메인이나 소프트웨어의 표현을 만들어 나가는 과정 유스케이스 모델링 정적 모델링, 동적 모델링, 행위 모델링 프로그래밍 품질보증 리뷰, 인스펙션, 테스트 배포 프로세스 관리 2장 소프트웨어 프로세스 폭포수 모델 (Waterfall Model) 각 단계가 다음 시작 전에 끝나야 함 -&amp;gt; 느림 프로토타입과 재사용의 기회가 줄어듦 프로토타입 모델 (Prototyping Model) 인간-기계 상호작용 프로토타입 프로토타입을 만든다 - 프로토타입을 평가한다 점증적 모델 (Incremental Model) 점증적 방법: 기능별로 릴리즈 반복적 방법: 릴리즈 할때마다 기능의 완성도를 높인다 기능이 부족하더라도 빨리 릴리즈 가능 나선형 모델 (Spiral Model) 진화 단계 계획 수립 위험 분석 개발 평가 반복적인 개발 및 테스트 -&amp;gt; 강인성 향상 관리, 위험 분석이 중요 진화적 모델 (Evolutionary Model) 초기에 요구사항을 파악하기 힘들고 구현이 어려운 경우, 요구사항 분석을 한 번이상 반복 UP (Unified Process) 도입 단계 : 프로젝트의 범위를 설정, 목표를 명확히 정련 단계 : 요구를 찾아내어 설계를 완성 구축 단계 : 제조 단계, 요구의 테스트 마무리 전환 단계 : 릴리즈 애자일 프로세스 (Agile Process) 특징 짧은 릴리즈와 반복 점증적 설계 사용자 참여 문서 최소화 비공식적 커뮤니케이션 요구와 환경의 변화를 가정 익스트림 프로그래밍 (eXtreme Pragramming) 애자일 방법론 중 하나 Planning : 요구사항을 작은 요소로 분할 Analysis Design Execution : Coding, Testing Wrapping : small release, process improvement Closure : launch 스크럼 (Scrum) 조직적으로 애자일 방법론을 적용</description></item><item><title>컴퓨터네트워크</title><link>https://bong-u.github.io/til/school/computer_network/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/computer_network/</guid><description>HTTP HTTP Method Method request payload response payload idempotent GET Optional O O HEAD Optional O O POST Yes O X PUT Yes O O DELETE Optional O O CONNECT Optional O X OPTIONS Optional O O TRACE Optional O O PATCH Yes O X HTTP Protocol Version HTTP/1.</description></item><item><title>컴파일러개론</title><link>https://bong-u.github.io/til/school/compiler/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/compiler/</guid><description>개요 컴퓨터와 인간이 소통하는 방법 어셈블리어 어셈블리어의 번역기는 어셈블러(Assembler)라고 한다 cpu칩셋이 바뀔때마다 어셈블리어가 바뀐다 고급언어 고급언어의 번역기는 컴파일러(Compiler)라고 한다 컴파일러의 정확한 정의 어떤 언어로 쓰여진 프로그램을 같은 역할의 다른 언어로 바꿔주는 프로그램
1952년 그레이스 호퍼(Grace Hopper)가 UNIVAC용 프로그래밍언어 A-0 컴파일러를 제작 컴파일러 vs 인터프리터 프로그램 처리과정 컴파일러의 처리 과정 Lexical analysis (어휘 분석) token을 생성하는일, token은 어휘의 최소 단위 Syntax analysis (구문 분석) token을 읽어서 오류를 검색, 구문 구조를 만든다 (주로 트리형태) Semantic analysis (의미 분석) type checking Intermediate code generation (중간 코드 생성) 중간 코드로 변환 Code optimization (코드 최적화) 중간 코드를 더 효율적으로 변환 Code generation (코드 생성) 목적 코드 생성 Lexical analysis (어휘 분석) token : 문법적으로 의미있는 최소 단위 FSA (Finite State Automata, 유한 상태 오토마타) token을 인식하는 방법 시작 상태 한 개와 끝 상태 여러 개를 가짐 DFA (Deterministic Finite Automata) FSA의 한 종류 각 상태에서 뻗어나가는 edge가 하나씩만 존재 ε가 붙은 edge 없음 분석한 토큰을 표현하는 방법 Lexeme = &amp;lt;토큰번호, 토큰 값&amp;gt;</description></item><item><title>운영체제 - 기말범위</title><link>https://bong-u.github.io/til/school/operatingsystem2/</link><pubDate>Mon, 29 May 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/operatingsystem2/</guid><description>06-File-Management Directory File Directory Directory도 일종의 파일이다 해당 파일 FCB의 식별자만 저장한다 inode (index node) Unix에서는 FCB와 inode가 같다 모든 파일, 폴더가 Unique한 값을 가진다. (root는 2로 고정) File Systems 파티션의 구조 boot block, super block, FCB list, data blocks Partition Control block (Super block) blocks 개수, free data blocks 개수, free data blocks list 저장 inode table, free inode 개수, free inode list 저장 File Control Block (FCB) UNIX에서 128byte의 크기를 가진다 파일 이름, 파일 크기, uid, gid, 파일 주소 등등 저장 Management of Data Blocks Contiguous Allocation 각각의 파일을 연속적으로 저장 Direct Access File grow problem 존재 External fragmentation, Internal fragmentation 발생 Chained Allocation Direct acess File grow problem X External fragmentation X Poor data safety (앞 블록에 문제가 생기면 뒤 블록도 사용 불가능) Indexed Allocation (현대에 사용) Direct access File grow problem X External fragmentation X Medium level data safety (index block만 괜찮으면 된다) Index block이 추가로 필요하다 Free-Space Management Counting N-M&amp;hellip; N번부터 M개의 블록이 비어있다.</description></item><item><title>데이터통신</title><link>https://bong-u.github.io/til/school/data_communication/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/data_communication/</guid><description>메시지(패킷, 프레임), 계층 OSI 7 Model Physical Data Link Network Transport Session Presentation Application TCP/IP 계층 계층 이름 메시지 형태 내용 1 Phisical Bits Bits 2 Data Link Ethernet Frame Ethernet 주소 3 Network IP packet, Datagram IP 주소 4 Transport TCP Segment, UDP Datagram Port 번호 5 Application HTTP 메시지, Email 메시지 URL, Email 주소 Protocol Suite HTTP - TCP - IP - ARP 아날로그 신호 - 사인 함수 $$ y(t) = A sin(2\pi ft + \varphi) $$</description></item><item><title>운영체제 - 중간범위</title><link>https://bong-u.github.io/til/school/operatingsystem1/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/operatingsystem1/</guid><description>운영체제 개요 운영체제의 역할 Program execution Access to computer resources (I/O device, Data&amp;hellip;) Error detection and response Accounting (ex: task manager) 운영체제의 발전 Serial Processing : No OS, No Job scheduling
Simple batch system
OS가 job을 할당 Controlled by monitor Uni-programming
다 실행될때까지 기다림 bad utilization Multiprogramming
The processor can switch to the other job better utilization, needs more memory Time sharing</description></item><item><title>자료구조</title><link>https://bong-u.github.io/til/school/data_structure/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/data_structure/</guid><description>제 1장 : 자료구조를 배우기 위한 준비 (230302) 배열 배열(Array): 동일한 타입의 원소들이 연속적인 메모리 공간에 할당되어 있는 기초적인 자료구조 추상데이터 타입 추상데이터타입(ADT:Abstract Data Type) : 데이터와 그 데이터에 대한 추상적인 연산들로써 구성 ADT =~ 자바의 interface, 자료구조 =~ 자바의 class 자료구조는 추상데이터타입을 구체적으로 구현한 것 1-2 수행시간의 분석 알고리즘의 성능: 수행시간을 나타내는 **시간복잡도(Time Complexity)**와 알고리즘이 수행되는 동안 사용되는 메모리 공간의 크기를 나타내는 **공간복잡도(Space Complexity)**에 기반하여 분석 시간 복잡도</description></item><item><title>221207 SYSP</title><link>https://bong-u.github.io/til/school/sysp_09_11/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/sysp_09_11/</guid><description>09-process1 예외적인 제어 흐름 하위 매커니즘 예외 (Exception) 상위 매커니즘 프로세스 컨텍스트 전환 OS 소프트웨어와 하드웨어 타이머로 구현 시그널 OS 소프트웨어로 구현 nolocal 점프 예외 테이블 (Exception Tables) 각 이벤트 타입은 예외번호 k를 갖는다 비동기형 예외 (Interrupt) 입출력 인터럽트 (ctrl + c)
하드 리셋 인터러트
소프트 리셋 인터럽트</description></item><item><title>221208 SYSP</title><link>https://bong-u.github.io/til/school/sysp_12_13/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0900</pubDate><guid>https://bong-u.github.io/til/school/sysp_12_13/</guid><description>12-memory-1 메모리에 관한 불편한 진실 메모리는 무한의 자원이 아니다 동적 메모리 할당 직접(explicit) vs 간접(implicit) 메모리 할당기 직접 할당 : 응용프로그램이 할당하고, 반환한다 ex) malloc, free 간접 할당 : 응용프로그램이 할당하지만, 반환하지는 않는다 ex) java의 garbage collector 프로세스의 메모리 이미지 스택은 아래로, 힙은 위로 성장한다 sbrk 함수가 추가적인 힙 메모리를 운영체제로부터 요청한다 (brk 포인터 이동) Malloc package 1#include &amp;lt;stdlib.</description></item></channel></rss>