<!doctype html><html>
<head>
<title> bong-u's TIL </title>
<meta charset=utf-8>
<script type=text/javascript src=https://bong-u.github.io/til-hugo/src/script.js></script>
<link rel=icon href=https://bong-u.github.io/til-hugo/favicon16.png sizes=16x16>
<link rel=icon href=https://bong-u.github.io/til-hugo/favicon32.png sizes=32x32>
<link href=https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-dark.min.css rel=stylesheet>
<link rel=stylesheet href=https://bong-u.github.io/til-hugo/src/style.css>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']], displayMath: [['$$','$$']]},
  });
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HE9FQR1ML7"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-HE9FQR1ML7')</script>
</head>
<body class=dark>
<header class="w-full text-center pt-3 pb-9">
<input type=checkbox id=toggleDarkMode onchange=toggleDarkModeHandler() hidden>
<label class="absolute right-0 my-2 mx-4 toggleSwitch" for=toggleDarkMode>
<span class=toggleButton></span>
</label>
<h1 class="text-4xl font-bold">
<a href=https://bong-u.github.io/til-hugo/>Bong-u's TIL</a>
</h1>
</header>
<script>let anchorsCache=null;document.addEventListener("DOMContentLoaded",()=>{window.addEventListener("scroll",()=>{const c=document.getElementById("TableOfContents"),b=document.querySelectorAll("#TableOfContents a"),a=getCurrentAnchor();let d=0;for(let c=0;c<b.length;c++)b[c].classList.remove("current"),b[c]===a&&(d=c);a&&a.classList.add("current"),c.scroll(0,a.offsetTop-c.offsetHeight/2)})});const getTocItem=a=>document.querySelector('[href="'+a+'"]'),getCurrentAnchor=()=>{const c=window.pageYOffset,a=getAnchors();let b=null;for(let d=0;d<a.length;d++){const e=getHeading(a[d]).getBoundingClientRect().top+c;if(e<c+window.innerHeight*.23)b=a[d];else break}return b||(b=a[0]),getTocItem(b)},getAnchors=()=>(anchorsCache||(anchorsCache=Array.from(document.querySelectorAll("#TableOfContents a")).map(a=>a.getAttribute("href"))),anchorsCache),getHeading=a=>document.getElementById(a.substr(1))</script>
<aside class="fixed right-0 w-56 gap-3 mx-9 hidden lg:flex">
<nav id=TableOfContents>
<ul>
<li><a href=#directory>Directory</a>
<ul>
<li><a href=#file-directory>File Directory</a></li>
<li><a href=#inode-index-node>inode (index node)</a></li>
</ul>
</li>
<li><a href=#file-systems>File Systems</a>
<ul>
<li><a href=#파티션의-구조>파티션의 구조</a></li>
<li><a href=#partition-control-block-super-block>Partition Control block (Super block)</a></li>
<li><a href=#file-control-block-fcb>File Control Block (FCB)</a></li>
</ul>
</li>
<li><a href=#management-of-data-blocks>Management of Data Blocks</a>
<ul>
<li><a href=#contiguous-allocation>Contiguous Allocation</a></li>
<li><a href=#chained-allocation>Chained Allocation</a></li>
<li><a href=#indexed-allocation-현대에-사용>Indexed Allocation (현대에 사용)</a></li>
<li><a href=#free-space-management>Free-Space Management</a></li>
</ul>
</li>
<li><a href=#file-system-example-unix>File System Example (UNIX)</a>
<ul>
<li><a href=#addresses-of-data-blocks>Addresses of Data Blocks</a></li>
<li><a href=#data-block-addressing>Data Block Addressing</a></li>
</ul>
</li>
<li><a href=#file-system-example-linux>File System Example (Linux)</a>
<ul>
<li><a href=#virtual-file-system-적용>Virtual File System 적용</a></li>
<li><a href=#linux-inode>Linux Inode</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href=#kernel-modules-for-io-management>Kernel Modules for IO Management</a>
<ul>
<li><a href=#kernel-io-management>Kernel I/O Management</a></li>
</ul>
</li>
<li><a href=#interrupt-handling>Interrupt handling</a>
<ul>
<li><a href=#interrupt>Interrupt</a></li>
<li><a href=#trap>Trap</a></li>
<li><a href=#system-call>System Call</a></li>
</ul>
</li>
<li><a href=#io-control--polling>I/O Control : Polling</a>
<ul>
<li><a href=#io-control>I/O Control</a></li>
<li><a href=#polling>Polling</a></li>
</ul>
</li>
<li><a href=#io-control--interrupt-io-dma>I/O Control : Interrupt I/O, DMA</a>
<ul>
<li><a href=#interrupt-driven-io>Interrupt-Driven I/O</a></li>
<li><a href=#dma-direct-memory-access>DMA (Direct Memory Access)</a></li>
</ul>
</li>
<li><a href=#disk-scheduling>Disk Scheduling</a>
<ul>
<li><a href=#disk-structure>Disk Structure</a></li>
<li><a href=#timing-of-a-disk-io-transfer>Timing of a Disk I/O Transfer</a></li>
<li><a href=#disk-scheduling-policies>Disk Scheduling Policies</a></li>
<li><a href=#disk-cache>Disk Cache</a></li>
</ul>
</li>
<li><a href=#raid>RAID</a>
<ul>
<li><a href=#raid-1>RAID</a></li>
<li><a href=#raid-0-non-redundant>RAID 0 (non-redundant)</a></li>
<li><a href=#raid-1-mirrored>RAID 1 (mirrored)</a></li>
<li><a href=#raid-3-bit-interleaved-parity>RAID 3 (bit-interleaved parity)</a></li>
<li><a href=#raid-4-block-level-parity>RAID 4 (block-level parity)</a></li>
<li><a href=#raid-5-block-level-distributed-parity>RAID 5 (block-level distributed parity)</a></li>
<li><a href=#raid-6-dual-redundancy>RAID 6 (dual redundancy)</a></li>
<li><a href=#raid-01-raid-10>RAID 01, RAID 10</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href=#memory-management>Memory Management</a>
<ul>
<li><a href=#memory-management-requirements>Memory Management Requirements</a></li>
<li><a href=#memory-partitioning>Memory Partitioning</a></li>
<li><a href=#buddy-system>Buddy System</a></li>
</ul>
</li>
<li><a href=#virtual-address-space>Virtual Address Space</a>
<ul>
<li><a href=#type-of-memory-addresses>Type of Memory Addresses</a></li>
<li><a href=#virtual-address-space-1>Virtual Address Space</a></li>
</ul>
</li>
<li><a href=#address-binding>Address Binding</a>
<ul>
<li><a href=#address-binding-1>Address binding</a></li>
<li><a href=#compile-time-binding>Compile time binding</a></li>
<li><a href=#load-time-binding>Load time binding</a></li>
<li><a href=#execution-time-binding>Execution time binding</a></li>
<li><a href=#relocation>Relocation</a></li>
<li><a href=#hardware-for-execution-time-binding>Hardware for Execution Time Binding</a></li>
</ul>
</li>
<li><a href=#paging>Paging</a>
<ul>
<li><a href=#paging-1>Paging</a></li>
<li><a href=#page-table>Page Table</a></li>
<li><a href=#page-number-and-offset>Page number and offset</a></li>
<li><a href=#address-translation-in-paging>Address translation in Paging</a></li>
<li><a href=#segmentation>Segmentation</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href=#advantages-of-virtual-memory>Advantages of Virtual Memory</a>
<ul>
<li><a href=#virtual-memory>Virtual Memory</a></li>
<li><a href=#types-of-memory>Types of Memory</a></li>
<li><a href=#execution-of-a-program>Execution of a Program</a></li>
<li><a href=#principle-of-locality>Principle of Locality</a></li>
</ul>
</li>
<li><a href=#demand-paging>Demand paging</a>
<ul>
<li><a href=#demand-paging-1>Demand paging</a></li>
<li><a href=#address-translation-in-demand-paging>Address Translation in demand paging</a></li>
<li><a href=#page-table-entry>Page Table Entry</a></li>
<li><a href=#modify-bit-in-page-table>Modify Bit in page table</a></li>
<li><a href=#sharing-of-pages>Sharing of Pages</a></li>
</ul>
</li>
<li><a href=#multi-level-page-table>Multi-level Page Table</a>
<ul>
<li><a href=#size-of-page-tabbles>Size of Page tabbles</a></li>
<li><a href=#two-level-scheme-for-32-bit-address>Two-Level Scheme for 32-bit address</a></li>
<li><a href=#two-level-paging-example>Two-Level Paging Example</a></li>
<li><a href=#addres-translation-scheme>Addres-Translation Scheme</a></li>
</ul>
</li>
<li><a href=#translation-lookaside-buffer>Translation Lookaside Buffer</a>
<ul>
<li><a href=#translation-lookaside-buffer-1>Translation Lookaside Buffer</a></li>
<li><a href=#effective-access-time>Effective Access Time</a></li>
</ul>
</li>
<li><a href=#page-replacement>Page Replacement</a>
<ul>
<li><a href=#replacement-policy>Replacement Policy</a></li>
<li><a href=#basic-replacement-algorithms>Basic Replacement Algorithms</a></li>
<li><a href=#performance-of-demand-paging>Performance of Demand Paging</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
<main class="flex w-full justify-center">
<section class="px-4 w-11/12 lg:w-1/2 xl:w-7/12">
<div class=mb-10>
<div class="flex justify-between items-baseline my-4 whitespace-nowrap gap-8">
<h1 id=title class="overflow-hidden overflow-ellipsis text-3xl font-bold">운영체제 - 기말범위</h1>
<div class="flex flex-col items-end">
<h4 id=date> CREATED 2023-05-29 </h4>
<h4 id=date> MODIFIED 2023-06-01</h4>
</div>
</div>
</div>
<article id=content class="bg-[var(--background-color)] markdown-body flex flex-col">
<h1 id=06-file-management>06-File-Management</h1>
<h2 id=directory>Directory</h2>
<h3 id=file-directory>File Directory</h3>
<ul>
<li>Directory도 일종의 파일이다</li>
<li>해당 파일 FCB의 식별자만 저장한다</li>
</ul>
<h3 id=inode-index-node>inode (index node)</h3>
<ul>
<li>Unix에서는 FCB와 inode가 같다</li>
<li>모든 파일, 폴더가 Unique한 값을 가진다. (root는 2로 고정)</li>
</ul>
<h2 id=file-systems>File Systems</h2>
<h3 id=파티션의-구조>파티션의 구조</h3>
<ul>
<li>boot block, super block, FCB list, data blocks</li>
</ul>
<h3 id=partition-control-block-super-block>Partition Control block (Super block)</h3>
<ul>
<li>blocks 개수, free data blocks 개수, free data blocks list 저장</li>
<li>inode table, free inode 개수, free inode list 저장</li>
</ul>
<h3 id=file-control-block-fcb>File Control Block (FCB)</h3>
<ul>
<li>UNIX에서 128byte의 크기를 가진다</li>
<li>파일 이름, 파일 크기, uid, gid, 파일 주소 등등 저장</li>
</ul>
<h2 id=management-of-data-blocks>Management of Data Blocks</h2>
<h3 id=contiguous-allocation>Contiguous Allocation</h3>
<ul>
<li>각각의 파일을 연속적으로 저장</li>
<li>Direct Access</li>
<li>File grow problem 존재</li>
<li><strong>External fragmentation</strong>, Internal fragmentation 발생</li>
</ul>
<h3 id=chained-allocation>Chained Allocation</h3>
<ul>
<li>Direct acess</li>
<li>File grow problem X</li>
<li>External fragmentation X</li>
<li>Poor data safety (앞 블록에 문제가 생기면 뒤 블록도 사용 불가능)</li>
</ul>
<h3 id=indexed-allocation-현대에-사용>Indexed Allocation (현대에 사용)</h3>
<ul>
<li>Direct access</li>
<li>File grow problem X</li>
<li>External fragmentation X</li>
<li>Medium level data safety (index block만 괜찮으면 된다)</li>
<li>Index block이 추가로 필요하다</li>
</ul>
<h3 id=free-space-management>Free-Space Management</h3>
<ul>
<li>Counting
<ul>
<li>N-M&mldr;</li>
<li>N번부터 M개의 블록이 비어있다.</li>
</ul>
</li>
<li>Linked List
<ul>
<li>비어있는 블록들을 연결리스트로 관리한다.</li>
</ul>
</li>
<li>Grouping
<ul>
<li>비어있는 블록들을 그룹으로 관리한다.</li>
</ul>
</li>
<li>Bit Vector
<ul>
<li>모든 블록들을 비트로 관리한다. (0이면 사용 중, 1이면 비어있음)</li>
<li>단점 : 용량을 많이 차지한다.</li>
</ul>
</li>
</ul>
<h2 id=file-system-example-unix>File System Example (UNIX)</h2>
<h3 id=addresses-of-data-blocks>Addresses of Data Blocks</h3>
<ul>
<li>Index 블록 하나는 4096 byte</li>
<li>4096 / 4 = 1024개의 블록 주소를 저장할 수 있다.</li>
<li>10개의 data blocks는 inode내(direct block field)에 저장한다</li>
</ul>
<h3 id=data-block-addressing>Data Block Addressing</h3>
<ul>
<li>direct block 10개 : 40KB (10 X 4 X 2^10 bytes)</li>
<li>single indirect block 1개 : 4MB (4KB X 2^10 = 2^22 bytes)</li>
<li>double indirect block 1개 : 4GB (4KB X 2^10 X 2^10 = 2^32 bytes)</li>
<li>triple indirect block 1개 : 4TB</li>
</ul>
<h2 id=file-system-example-linux>File System Example (Linux)</h2>
<h3 id=virtual-file-system-적용>Virtual File System 적용</h3>
<h3 id=linux-inode>Linux Inode</h3>
<ul>
<li>Inode의 크기 : 128 bytes (ext2, ext3), 256 bytes (ext4)</li>
<li>Direct block <strong>12개</strong>, Indirect block 3개</li>
</ul>
<h1 id=07-io-management-disk-scheduling>07-IO-Management-Disk-Scheduling</h1>
<h2 id=kernel-modules-for-io-management>Kernel Modules for IO Management</h2>
<h3 id=kernel-io-management>Kernel I/O Management</h3>
<ol>
<li>Device Scheduling</li>
<li>Error handling</li>
<li>Buffering (copy semantics를 유지)</li>
<li>Caching : 빠른 속도를 위해 사용</li>
<li>Spooling : 보조 기억 장치에 임시로 저장 (여러 사람이 공유하기 때문)</li>
</ol>
<h2 id=interrupt-handling>Interrupt handling</h2>
<h3 id=interrupt>Interrupt</h3>
<ul>
<li>주변 장치 -> OS : 비동기적 이벤트의 발생을 알림</li>
<li>IDT (Interrupt Descriptor Table = IVT) : 인터럽트 번호와 ISR의 주소를 저장</li>
<li>ISR (Interrupt Service Routine) : 인터럽트 발생 시 실행되는 함수</li>
<li>Interrupt 처리 과정
<ol>
<li>Mode change</li>
<li>IDT에서 ISR의 주소를 찾아서 실행</li>
<li>ISR에서 급한 일 부터 처리, 필요하면 미룬다</li>
<li>Scheduler가 할 일을 결정</li>
</ol>
</li>
</ul>
<h3 id=trap>Trap</h3>
<ul>
<li>OS에게 동기적 이벤트의 발생을 알림</li>
<li>예) div_by_zero, seg_fault, protection_fault, page_fault</li>
<li>page fault만 프로세스를 종료 시키지 않음</li>
<li>Kernel은 Interrupt와 같은 방식으로 처리</li>
</ul>
<h3 id=system-call>System Call</h3>
<ul>
<li>Process -> OS : 동기적 이벤트의 발생을 알림</li>
<li>System call 처리
<ol>
<li>Using system call table ex) int $0x80</li>
<li>sysenter 명령</li>
</ol>
</li>
</ul>
<h2 id=io-control--polling>I/O Control : Polling</h2>
<h3 id=io-control>I/O Control</h3>
<ul>
<li>Polling : 주기적으로 I/O 장치의 상태를 확인</li>
<li>Interrupt-driven I/O : I/O 장치가 인터럽트 발생</li>
<li>DMA(Direct Memory Access) : CPU의 개입 없이 메모리와 주변장치 사이의 데이터 전송</li>
</ul>
<h3 id=polling>Polling</h3>
<ul>
<li>Busy-wait cycle
<ul>
<li>Host가 busy bit를 반복적으로 확인</li>
<li>Host가 write bit 설정, data-out register에 데이터 저장</li>
<li>Host가 command-ready bit 설정</li>
<li>Controller가 command-ready bit 설정을 확인하면 busy bit 설정</li>
<li>Controller가 control register (write command)를 읽고, data-out register의 데이터를 읽는다</li>
<li>I/O가 끝나면 controller가 command-ready bit, busy bit 해제</li>
</ul>
</li>
</ul>
<ul>
<li>특징
<ul>
<li>I/O가 빨리 끝나면 효율적, 늦게 끝나면 비효율적</li>
</ul>
</li>
</ul>
<h2 id=io-control--interrupt-io-dma>I/O Control : Interrupt I/O, DMA</h2>
<h3 id=interrupt-driven-io>Interrupt-Driven I/O</h3>
<p><img src=/static/image/os_interrupt_driven_io.png alt="Interrupt driven I/O"></p>
<ul>
<li>1~3은 Polling과 동일</li>
<li>4 : Process management를 통해 Context switch</li>
<li>8 : IO가 끝나면 Interrupt ReQuest(IRQ)를 cpu에게 보낸다</li>
</ul>
<ul>
<li>장점 : 주어진 시간안에 많은 프로세스 수용 가능, I/O가 느릴수록 효율적</li>
<li>단점 : I/O가 빠르면 비효율적 (잦은 Context Switch, mode change)</li>
</ul>
<h3 id=dma-direct-memory-access>DMA (Direct Memory Access)</h3>
<ul>
<li>기존 방식은 무조건 processor를 거쳐가야한다</li>
<li>DMA 모듈이 I/O와 Memory 사이 역할 수행, 끝나면 Interrupt 발생</li>
<li>장점 : CPU가 다른 작업 가능, 빠르다</li>
</ul>
<h2 id=disk-scheduling>Disk Scheduling</h2>
<h3 id=disk-structure>Disk Structure</h3>
<ul>
<li>Sector, Track, Cylinder</li>
<li>Disk는 logical block의 배열이다</li>
</ul>
<h3 id=timing-of-a-disk-io-transfer>Timing of a Disk I/O Transfer</h3>
<ul>
<li>Seek time : 성능에 큰 영향을 미친다</li>
<li>Rotational delay</li>
<li>Transfer time</li>
</ul>
<h3 id=disk-scheduling-policies>Disk Scheduling Policies</h3>
<ul>
<li>FIFO
<ul>
<li>요청 순서대로 처리</li>
</ul>
</li>
<li>SSTF (Shortest Seek Time First)
<ul>
<li>현재 위치에서 가장 가까운 요청을 처리</li>
<li>starvation 문제 발생 (예를 들어 작은 숫자만 나오면?)</li>
</ul>
</li>
<li>SCAN (Elevator Algorithm)
<ul>
<li>한 방향으로 훑으면서 처리</li>
</ul>
</li>
<li>성능 비교
<ul>
<li>SSTF > SCAN > FIFO</li>
</ul>
</li>
</ul>
<h3 id=disk-cache>Disk Cache</h3>
<ul>
<li>Main memory에 몇몇 섹터의 복사본을 저장</li>
<li>Replacement Policy
<ol>
<li>LRU (Least Recently Used)</li>
</ol>
<ul>
<li>가장 오랫동안 사용하지 않은 섹터를 교체</li>
</ul>
<ol>
<li>LFU (Least Frequently Used)</li>
</ol>
<ul>
<li>가장 적게 사용된 섹터를 교체</li>
</ul>
</li>
</ul>
<h2 id=raid>RAID</h2>
<h3 id=raid-1>RAID</h3>
<blockquote>
<p>Redundant Array of Inexpensive Disks : 저렴한 여러 개의 디스크 묶음</p>
</blockquote>
<h3 id=raid-0-non-redundant>RAID 0 (non-redundant)</h3>
<ul>
<li>데이터를 여러 디스크에 분산 저장</li>
<li>장점 : 용량이 4배</li>
<li>단점 : 하나의 디스크가 고장나면 모든 데이터 손실</li>
</ul>
<h3 id=raid-1-mirrored>RAID 1 (mirrored)</h3>
<ul>
<li>RAID 0을 복제</li>
<li>장점 : 신뢰성이 높다</li>
<li>단점 : 디스크가 2배로 들어간다</li>
</ul>
<h3 id=raid-3-bit-interleaved-parity>RAID 3 (bit-interleaved parity)</h3>
<ul>
<li>한 디스크에 parity bit를 저장 (같은 위치의 bit들의 parity)</li>
<li>장점 : 하나의 디스크 복원 가능</li>
<li>단점 : 어떤 디스크가 고장났는지 알 수 없다, 5개를 동시에 읽어서 느림</li>
</ul>
<h3 id=raid-4-block-level-parity>RAID 4 (block-level parity)</h3>
<ul>
<li>한 디스크에 parity bit를 저장 (같은 위치의 <strong>block</strong>들의 parity)</li>
<li>장점 : 블록 단위 -> 병렬적으로 IO 가능 (RAID 3보다 빠름)</li>
<li>단점 : 어떤 디스크가 고장났는지 알 수 없다</li>
</ul>
<h3 id=raid-5-block-level-distributed-parity>RAID 5 (block-level distributed parity)</h3>
<ul>
<li>RAID 4와 동일하나 parity bit를 여러 디스크에 분산 저장</li>
</ul>
<h3 id=raid-6-dual-redundancy>RAID 6 (dual redundancy)</h3>
<ul>
<li>RAID 5와 동일하나 parity bit를 2개 저장 (1개는 odd, 1개는 even)</li>
<li>장점 : RAID5 보다 높은 신뢰성</li>
</ul>
<h3 id=raid-01-raid-10>RAID 01, RAID 10</h3>
<ul>
<li>RAID 0과 RAID 1을 합친 것</li>
<li>RAID 01 &lt; RAID 10</li>
</ul>
<h1 id=08-memory-management>08-Memory-Management</h1>
<h2 id=memory-management>Memory Management</h2>
<h3 id=memory-management-requirements>Memory Management Requirements</h3>
<ul>
<li>Memory Allocation : 프로세스별로 메모리 할당</li>
<li>Memory Protection : 각 프로세스가 허용된 영역만 접근 가능</li>
<li>Relocation : 흩어진 작은 공간을 합치기</li>
<li>Sharing : 부모 자식 프로세스 간 shared memory</li>
</ul>
<h3 id=memory-partitioning>Memory Partitioning</h3>
<ul>
<li>
<p>Fixed Partitioning : 같은 크기의 공간으로 나눠서 할당</p>
<ul>
<li>장점 : 간단하다</li>
<li>단점 : 내부 단편화 발생</li>
</ul>
</li>
<li>
<p>Dynamic Partitioning : 프로세스 크기에 맞게 할당</p>
<ul>
<li>장점 : 내부 단편화 발생 X</li>
<li>단점 : 외부 단편화 발생 (compaction을 통해 해결 가능 but, overhead가 크다)</li>
</ul>
</li>
<li>
<p>Dynamic Partition Placement Algorithm</p>
<ul>
<li>First-fit : 처음으로 맞는 공간에 넣는다
<ul>
<li>장점 : 빠르다</li>
<li>단점 : 메모리 효율이 좋지 않다</li>
</ul>
</li>
<li>Best-fit : 끝까지 조사해서 가장 비슷한 곳에 할당
<ul>
<li>장점 : 느리다</li>
<li>단점 : 메모리 효율이 좋다</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=buddy-system>Buddy System</h3>
<ul>
<li>Allocation
<ul>
<li>2^k 크기의 공간을 할당</li>
</ul>
</li>
<li>Deallocation
<ul>
<li>Buddy 한 쌍이 모두 free인 경우, 합친다 (탐색 Overhead를 줄이기 위해)</li>
</ul>
</li>
<li>장점 : 외부 단편화가 거의 없다</li>
<li>단점 : 내부 단편화 발생</li>
</ul>
<h2 id=virtual-address-space>Virtual Address Space</h2>
<h3 id=type-of-memory-addresses>Type of Memory Addresses</h3>
<ul>
<li>Physical address : 실제 메모리 주소</li>
<li>Logical address : 프로세스가 보는 주소</li>
<li>Virtual address : Virtaul memory의 Logical address</li>
<li>Relative address (주소 계산 방식) : 상대적인 주소</li>
</ul>
<h3 id=virtual-address-space-1>Virtual Address Space</h3>
<ul>
<li>크기 : 4GB (32bit 컴퓨터) : 0x00000000 ~ 0xFFFFFFFF</li>
<li>kernel - stack - heap - bss - data - code</li>
</ul>
<h2 id=address-binding>Address Binding</h2>
<h3 id=address-binding-1>Address binding</h3>
<ul>
<li>instruction과 데이터의 Physical address를 알아내는 것</li>
<li>3가지 상황에 일어날 수 있다 (Compile time, Load time, Execution time)</li>
</ul>
<h3 id=compile-time-binding>Compile time binding</h3>
<ul>
<li>Compile할때, base address를 알려줌으로써 미리 physical address를 넣어놓는다</li>
<li>Logical address = Physical address</li>
<li>문제점 : Relocation 불가 (base address가 바뀌면 다시 compile 해야함)</li>
</ul>
<h3 id=load-time-binding>Load time binding</h3>
<ul>
<li>Load할때, physical address를 계산</li>
<li>Logical address = Physical address</li>
<li>문제점 : Relocation 불가</li>
</ul>
<h3 id=execution-time-binding>Execution time binding</h3>
<ul>
<li>실행할 때, physical address를 계산</li>
<li>Logical address != Physical address</li>
</ul>
<h3 id=relocation>Relocation</h3>
<ul>
<li>일어나는 이유 : Swapping, Compaction</li>
</ul>
<h3 id=hardware-for-execution-time-binding>Hardware for Execution Time Binding</h3>
<ul>
<li>Base register : 시작 주소</li>
<li>Bounds register (limit register) : 끝 주소</li>
<li>Adder가 Base Register + releative address 계산</li>
<li>Comparato가 Bounds Register와 비교</li>
<li>영역 밖인 경우 Segementation Fault(Trap) 발생</li>
</ul>
<h2 id=paging>Paging</h2>
<h3 id=paging-1>Paging</h3>
<ul>
<li>프로세스를 같은 크기의 페이지로 나눈다</li>
<li>page size = frame size = disk block size = 4KB</li>
<li>Internal fragmentation 발생 (무시 가능)</li>
</ul>
<h3 id=page-table>Page Table</h3>
<p><img src=/static/image/os_page_table.png alt="page table"></p>
<ul>
<li>PCB에 저장 되어서 관리</li>
<li>Virtual Memory 사용 시 N과 frame number가 섞여서 존재</li>
</ul>
<h3 id=page-number-and-offset>Page number and offset</h3>
<ul>
<li>Logical address = Page number + offset</li>
<li>Page size 16 Bytes (128bit), 8 bit address인 경우</li>
<li>필요한 주소 개수 = 128 / 8 = 16개</li>
<li>offset = 4bit (2 ^ 4 = 16)</li>
<li>page number = 8 - 4 = 4bit (남는 거)</li>
</ul>
<h3 id=address-translation-in-paging>Address translation in Paging</h3>
<ul>
<li>Logical address -> Physical address</li>
<li>offset은 그대로, page 번호만 frame 번호로 바꾼다</li>
</ul>
<h3 id=segmentation>Segmentation</h3>
<ul>
<li>프로세스를 다른 크기의 논리적 단위인 세그먼트로 나눈다</li>
<li>Dynamic partitioning과 유사</li>
</ul>
<ul>
<li>논리적으로 비슷한 것들을 묶는다.</li>
</ul>
<h1 id=09-virtual-memory>09-Virtual-Memory</h1>
<h2 id=advantages-of-virtual-memory>Advantages of Virtual Memory</h2>
<h3 id=virtual-memory>Virtual Memory</h3>
<ul>
<li>전체 프로세스가 메모리에 올라갈 필요가 없다</li>
<li>더 많은 프로세스 수용 가능 -> swap 빈도 감소, 좋은 반응성</li>
<li>전체 메모리 보다 큰 프로세스도 실행 가능</li>
</ul>
<h3 id=types-of-memory>Types of Memory</h3>
<ul>
<li>Real Memory
<ul>
<li>address : Real address, Physical address, Absolute address</li>
</ul>
</li>
<li>Virtual Memory
<ul>
<li>address : Logical address, Virtual address</li>
</ul>
</li>
</ul>
<h3 id=execution-of-a-program>Execution of a Program</h3>
<ul>
<li>Resident set : Main memory에 존재하는 프로세스 집합</li>
<li>Main Memory에 없는 Page가 필요한 경우 -> Page fault (interrupt)</li>
<li>해당 프로세스 block -> 다른 프로세스 실행 -> Disk I/O 끝나면 다시 ready</li>
</ul>
<h3 id=principle-of-locality>Principle of Locality</h3>
<ul>
<li>프로세스의 프로그램 및 데이터 참조는 뭉친다는 성질</li>
<li>Virtual Memory가 효율적인 이유 중 한 가지</li>
</ul>
<h2 id=demand-paging>Demand paging</h2>
<h3 id=demand-paging-1>Demand paging</h3>
<ul>
<li>Virtual Memory의 두가지 방법
<ol>
<li>Demand paging</li>
<li>Demand segmentation : 느려서 사용 하지 않는다</li>
</ol>
</li>
</ul>
<h3 id=address-translation-in-demand-paging>Address Translation in demand paging</h3>
<ul>
<li><em>Page table base register</em>에 page table 시작 주소를 저장</li>
<li>매번 2번씩 Main memory를 access할 필요 없음</li>
</ul>
<h3 id=page-table-entry>Page Table Entry</h3>
<ul>
<li>
<table>
<thead>
<tr>
<th>P</th>
<th>M</th>
<th>R</th>
<th>U</th>
<th>W</th>
<th>COW</th>
<th>page frame number (p`)</th>
</tr>
</thead>
</table>
</li>
</ul>
<ul>
<li>P : present(valid) bit : Main memory에 존재하는지 여부</li>
<li>M : modified bit : 페이지가 수정되었는지 여부</li>
<li>R : referenced bit : 페이지를 접근한적 있는지 여부</li>
<li>U : user mode : User context에 해당하는지 여부</li>
<li>W : writable : 페이지가 쓰기 가능한지 여부</li>
<li>COW : copy-on-write : 페이지를 부모랑 공유하는지 여부</li>
</ul>
<h3 id=modify-bit-in-page-table>Modify Bit in page table</h3>
<ul>
<li>M bit가 0이면 디스크에 반영하지 않고 삭제 가능</li>
</ul>
<h3 id=sharing-of-pages>Sharing of Pages</h3>
<ul>
<li>같은 페이지를 공유해야할 때, Page table에 같은 주소를 저장</li>
</ul>
<h2 id=multi-level-page-table>Multi-level Page Table</h2>
<h3 id=size-of-page-tabbles>Size of Page tabbles</h3>
<ul>
<li>큰 프로세스는 1개의 page table로 처리불가</li>
<li>-> Multi-level apge table</li>
</ul>
<h3 id=two-level-scheme-for-32-bit-address>Two-Level Scheme for 32-bit address</h3>
<ul>
<li>1개의 Page Table이 수용하는 페이지수는 = 1K개</li>
<li>4GB User address space = 1M개의 페이지</li>
<li>-> 페이지 테이블이 더 필요</li>
</ul>
<h3 id=two-level-paging-example>Two-Level Paging Example</h3>
<ul>
<li>Page number가 2개 존재</li>
<li>page number1 : 10bit</li>
<li>page number2 : 10bit</li>
<li>page offset : 12bit</li>
</ul>
<h3 id=addres-translation-scheme>Addres-Translation Scheme</h3>
<ul>
<li>Page 크기 4096B / Page table크기 4B = 1024</li>
<li>-> page number의 개수 = 10bit (2^10=1024)</li>
<li>페이지의 크기 4096B이기 때문에</li>
<li>-> Offset bit = 12bit (2^12=4096)</li>
</ul>
<h2 id=translation-lookaside-buffer>Translation Lookaside Buffer</h2>
<h3 id=translation-lookaside-buffer-1>Translation Lookaside Buffer</h3>
<ul>
<li>계층이 많아지면 시간이 오래걸린다</li>
<li>TLB에 access한 순서대로 저장</li>
<li>TLB는 병렬로 탐색, O(1)로 탐색가능</li>
<li>TLB 확인 -> 없으면 Page table 확인 -> 없으면 Page fault</li>
</ul>
<h3 id=effective-access-time>Effective Access Time</h3>
<ul>
<li>Memory cycle = 1이라고 가정</li>
<li>TLB 읽는 시간 = $\varepsilon$</li>
<li>TLB hit ratio = $\alpha$</li>
<li>EAT = TLB에 있을 때 걸리는 시간 + 없을때 걸리는 시간
$$ EAT = (\varepsilon+1)\alpha + (\varepsilon+1+1)(1-\alpha) = 2+\varepsilon-\alpha $$</li>
</ul>
<h2 id=page-replacement>Page Replacement</h2>
<h3 id=replacement-policy>Replacement Policy</h3>
<ul>
<li>Main Memory가 꽉차면 page를 swap out 시켜야한다</li>
</ul>
<h3 id=basic-replacement-algorithms>Basic Replacement Algorithms</h3>
<ul>
<li>FIFO
<ul>
<li>가장 오래된 페이지를 교체</li>
<li>비효율적</li>
</ul>
</li>
<li>Optimal policy
<ul>
<li>가장 나중에 사용될 페이지를 교체</li>
<li>나중에 어떤 page가 필요할지 아는 경우 사용가능</li>
</ul>
</li>
<li>Least Recently Used (LRU)
<ul>
<li>가장 오래전에 사용된 페이지를 교체</li>
<li>마지막으로 언제 쓰였는지 항상 찾아야 한다 -> Overhead 발생</li>
</ul>
</li>
<li>Clock Policy (Second change algorithm)
<ul>
<li>돌아가면서 user bit -= 1</li>
<li>user == 0이면 교체</li>
<li>페이지를 사용하면 user 비트 = 1</li>
</ul>
</li>
<li>성능 비교
<ul>
<li>FIFO &lt; Clock &lt; LRU &lt; OPT</li>
</ul>
</li>
<li>Enhanced Clock Policy
<ul>
<li>U비트와 M비트에 따라 우선순위 부여</li>
</ul>
<ol>
<li>U = 0, M = 0</li>
<li>U = 0, M = 1</li>
<li>U = 1, M = 0</li>
<li>U = 1, M = 1</li>
</ol>
</li>
</ul>
<h3 id=performance-of-demand-paging>Performance of Demand Paging</h3>
<ul>
<li>Page Fault Rate = page fault 횟수 / page 불러오는 횟수</li>
<li>Effective Access Time(EAT)</li>
<li>= (1-p) x memory access + p x (page fault overhead + swap page out + swap page in + restart overhead)</li>
</ul>
</article>
<div id=meta class=py-10>
<div>
<div class="flex justify-between w-full whitespace-nowrap">
<a class="previous mr-5 overflow-hidden overflow-ellipsis" href=/til-hugo/school/datacommunication/>
데이터통신</a>
</div>
</div>
</div>
</section>
</main>
</body>
</html>